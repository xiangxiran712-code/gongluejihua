<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>攻略计划</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        :root {
            --bg-color: #1a202c;
            --text-color: #ffffff;
            --glass-container-bg: rgba(255, 255, 255, 0.15);
            --user-bubble-bg: rgba(60, 179, 113, 0.7);
            --user-bubble-text: #ffffff;
            --ai-bubble-bg: rgba(255, 255, 255, 0.8);
            --ai-bubble-text: #000000;
            --main-btn-bg: #4c51bf;
            --main-btn-hover: #434190;
            --custom-font: 'Inter', sans-serif;
        }

        html { height: 100%; }
        body {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #2d3748;
            padding: 20px;
            box-sizing: border-box;
            font-family: var(--custom-font);
            color: var(--text-color); /* 全局文字颜色 */
            transition: padding 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .phone-wrapper {
            width: 95vw;
            max-width: 420px;
            aspect-ratio: 390 / 844;
            margin: auto;
            transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        #phone-frame {
            position: relative;
            width: 100%;
            height: 100%;
            background: #111;
            border-radius: 40px;
            box-shadow: 0 20px 50px -10px rgba(0,0,0,0.5); /* 内部阴影已移除 */
            padding: 10px;
            box-sizing: border-box;
            transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        #phone-screen {
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            border-radius: 30px;
            overflow: hidden;
            position: relative;
            transition: background-image 0.5s ease-in-out, background-color 0.5s ease-in-out, border-radius 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            /* Prevents browser-level pull-to-refresh/navigation gestures */
            touch-action: none;
        }
        /* --- Fullscreen Mode --- */
        body.fullscreen-mode {
            padding: 0;
        }
        body.fullscreen-mode .phone-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: none;
            aspect-ratio: auto;
            z-index: 10000;
        }
        body.fullscreen-mode #phone-frame {
            border-radius: 0;
            box-shadow: none;
            padding: 0;
        }
        body.fullscreen-mode #phone-screen {
            border-radius: 0;
        }
        
        /* --- Fullscreen Home Page Layout Adjustments --- */
        body.fullscreen-mode #home-content-wrapper {
            /* This makes the wrapper disappear, promoting its children to be positioned relative to #home-page */
            display: contents;
        }
        body.fullscreen-mode #home-avatar-section,
        body.fullscreen-mode #home-buttons-section {
            position: absolute;
            width: auto;
            padding: 0;
        }
        body.fullscreen-mode #home-avatar-section {
            top: 50%; /* <<<<< MODIFIED: Moved down to be vertically centered on the left side */
            left: 25%;
            transform: translate(-50%, -50%);
            align-items: center;
        }
        body.fullscreen-mode #home-buttons-section {
            top: 50%;
            right: 25%;
            transform: translate(50%, -50%);
        }
        body.fullscreen-mode .mini-player-container {
            top: 80%;
            left: 50%;
            bottom: auto;
            transform: translate(-50%, -50%);
        }
        
        #app.container {
            height: 100%;
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* This class allows elements to be scrolled normally */
        .scrollable-content {
            touch-action: pan-y; /* Allow vertical scrolling */
            -webkit-overflow-scrolling: touch; /* For smoother scrolling on iOS */
        }
        .glass-container {
            background: var(--glass-container-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .menu-btn {
            padding: 0.6rem 1.5rem;
            font-weight: bold;
            font-size: 1rem;
            width: 140px;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background: var(--glass-container-bg);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 9999px;
            color: var(--text-color);
        }
        .menu-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .message-bubble {
            display: inline-block;
            font-size: 0.9rem;
            padding: 0.6rem 0.9rem;
            max-width: 75%;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            position: relative;
        }
        .message-bubble.user {
            background-color: var(--user-bubble-bg);
            align-self: flex-end;
            border-radius: 12px 12px 0 12px;
            color: var(--user-bubble-text); /* 独立颜色 */
        }
        .message-bubble.ai {
            background-color: var(--ai-bubble-bg);
            align-self: flex-start;
            border-radius: 12px 12px 12px 0;
            color: var(--ai-bubble-text); /* 独立颜色 */
        }
        .chat-header, .chat-footer, .batch-actions-footer {
            position: sticky;
            width: 100%;
            z-index: 10;
            padding-left: 1rem;
            padding-right: 1rem;
        }
        .chat-header { top: 0; padding-top: 1rem; padding-bottom: 0.5rem; }

        .chat-header.no-blur {
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .chat-footer, .batch-actions-footer { bottom: 0; padding-bottom: 1rem; padding-top: 0.5rem; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background-color: rgba(255, 255, 255, 0.3); border-radius: 20px; }
        
        .datetime-display {
            position: absolute;
            top: 3.5rem; /* MODIFIED */
            right: 1.5rem;
            text-align: right;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
        }
        .time {
            font-size: 2.5rem;
            font-weight: bold;
        }
        .date {
            font-size: 0.8rem;
            opacity: 0.8;
        }
        #diary-btn {
            background: none;
            border: none;
            color: inherit;
            font-size: 1.5rem;
            opacity: 0.8;
            transition: all 0.3s ease;
            cursor: pointer;
            padding: 0.25rem;
        }
        #sui-btn {
            position: absolute;
            top: 1.5rem;
            left: 1.5rem;
            z-index: 20;
            padding: 0.5rem 1rem;
            font-weight: 700;
            font-size: 1.2rem;
            letter-spacing: 2px;
            text-shadow: 0 0 8px rgba(255,255,255,0.5);
            background: var(--glass-container-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: var(--text-color);
            opacity: 0.8;
            transition: all 0.3s ease;
        }
        #diary-btn:hover, #sui-btn:hover {
            opacity: 1;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        /* --- 全局颜色应用强化 --- */
        input, textarea, select {
            color: var(--text-color);
        }
        input::placeholder, textarea::placeholder {
            color: var(--text-color);
            opacity: 0.6;
        }
        .mini-player, .diary-content {
            color: var(--text-color);
        }
        .mini-player-container {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            width: calc(100% - 2rem); /* 确保容器不会超出屏幕 */
            display: flex;
            justify-content: center;
        }
        .mini-player {
            width: 300px;
            max-width: 100%; /* 确保播放器本身不会超出容器 */
            background: var(--glass-container-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            /* box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); MODIFIED: Shadow removed */
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        .player-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .player-header h2 { font-size: 12px; font-weight: 600; text-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); }
        .import-btn { background: rgba(255, 255, 255, 0.2); border: none; color: inherit; padding: 4px 8px; border-radius: 50px; font-size: 10px; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; gap: 5px; }
        .import-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .player-content { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
        .info-section { flex-grow: 1; min-width: 0; }
        .song-info { margin-bottom: 6px; }
        .song-info h3 { font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; }
        .song-info p { font-size: 10px; opacity: 0.8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .album-art { width: 50px; height: 50px; border-radius: 6px; background: linear-gradient(45deg, #ee9ca7, #ffdde1); overflow: hidden; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255, 255, 255, 0.3); flex-shrink: 0; cursor: pointer; position: relative; transition: all 0.3s ease; }
        .album-art:hover::after { content: '换封面'; position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.7); color: white; font-size: 9px; padding: 2px; text-align: center; }
        .album-art i { font-size: 20px; color: rgba(255, 255, 255, 0.8); }
        .album-art img { width: 100%; height: 100%; object-fit: cover; }
        .progress-area { margin-bottom: 6px; }
        .progress-container { background: rgba(255, 255, 255, 0.2); border-radius: 5px; height: 4px; margin-bottom: 4px; cursor: pointer; position: relative; }
        .progress-bar { background: linear-gradient(90deg, #fff, #c2e9fb); border-radius: 5px; height: 100%; width: 0%; transition: width 0.1s linear; }
        .progress-time { display: flex; justify-content: space-between; font-size: 9px; opacity: 0.8; }
        .controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0; }
        .control-btn { background: none; border: none; color: inherit; font-size: 11px; cursor: pointer; padding: 4px; opacity: 0.8; transition: all 0.2s; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; }
        .control-btn:hover { opacity: 1; background: rgba(255, 255, 255, 0.1); }
        .play-pause { background: rgba(255, 255, 255, 0.2); width: 28px; height: 28px; border-radius: 50%; font-size: 11px; }
        .play-pause:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.05); }
        .volume-container { display: flex; align-items: center; gap: 5px; }
        .volume-container i { font-size: 11px; opacity: 0.8; }
        .volume-slider { -webkit-appearance: none; width: 50px; height: 3px; background: rgba(255, 255, 255, 0.2); border-radius: 5px; outline: none; }
        .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; border-radius: 50%; background: white; cursor: pointer; }
        .file-input, .cover-input { display: none; }
        .playlist-btn { background: none; border: none; color: inherit; font-size: 11px; cursor: pointer; padding: 4px 6px; opacity: 0.8; transition: all 0.2s; border-radius: 4px; }
        .playlist-btn:hover { opacity: 1; background: rgba(255, 255, 255, 0.1); }
        .song-list { margin-top: 10px; text-align: left; max-height: 100px; overflow-y: auto; background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 8px; display: none; }
        .song-list::-webkit-scrollbar { width: 5px; }
        .song-list::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); border-radius: 10px; }
        .song-list::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 10px; }
        .song-list::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.4); }
        .song-item { padding: 5px 8px; border-radius: 4px; margin-bottom: 4px; cursor: pointer; transition: background 0.2s; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none; }
        .song-item:hover { background: rgba(255, 255, 255, 0.2); }
        .song-item.active { background: rgba(255, 255, 255, 0.3); font-weight: 500; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .rotating { animation: rotate 15s linear infinite; }
        .diary-entry, .memory-item { background: rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1rem; position: relative; }
        .diary-content strong { font-weight: bold; color: #fcd34d; }
        .diary-content em { font-style: italic; color: #93c5fd; }
        .diary-content del { text-decoration: line-through; opacity: 0.7; }
        .diary-delete-btn { position: absolute; top: 0.5rem; right: 0.5rem; background: none; border: none; color: inherit; opacity: 0.5; cursor: pointer; transition: opacity 0.2s; }
        .diary-delete-btn:hover { opacity: 1; }
        .batch-delete-checkbox { position: absolute; top: 0.75rem; left: 0.75rem; }
        .form-checkbox { background-color: #4a5568; border-color: #718096; }

        /* --- SUI Page Specific Styles --- */
        .sui-nav-btn {
            color: var(--text-color);
            opacity: 0.6;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px; /* Overlap with parent border */
        }
        .sui-nav-btn:hover {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.05);
        }
        .sui-nav-btn.active {
            opacity: 1;
            color: #c4b5fd; /* A highlight color */
            border-bottom-color: #c4b5fd;
        }
        .sui-section {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1rem;
        }
        .sui-list {
            padding-right: 8px; /* For scrollbar gap */
        }
        .sui-list-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            position: relative;
        }
        .sui-list-item .timestamp {
            font-size: 0.7rem;
            opacity: 0.6;
            display: block;
            margin-bottom: 4px;
        }
        .sui-list-item .amount-positive { color: #4ade80; }
        .sui-list-item .amount-negative { color: #f87171; }
        .sui-list-item .chat-with { font-weight: bold; color: #93c5fd; }
        .sui-chat-log {
            margin-top: 6px;
            padding-left: 10px;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
        }
        .sui-chat-log p {
            margin-bottom: 2px;
            line-height: 1.4;
        }
        .sui-list-item .url { color: #a78bfa; word-break: break-all; }
        .sui-browsing-session {
            margin-top: 6px;
            padding-left: 10px;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
        }
        .sui-browsing-session p {
            margin-bottom: 2px;
            line-height: 1.4;
            font-size: 0.75rem;
        }
        .sui-browsing-session .url {
            opacity: 0.7;
            font-size: 0.7rem;
        }
        .sui-item-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 5; /* Ensure buttons are on top */
        }
        .sui-list-item:hover .sui-item-actions {
            opacity: 1;
        }
        .sui-action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-color);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            cursor: pointer;
        }
        .sui-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .sui-section-clear-btn {
            background: rgba(255, 82, 82, 0.2);
            border: 1px solid rgba(255, 82, 82, 0.4);
            color: #ffcdd2;
            padding: 2px 8px;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .sui-section-clear-btn:hover {
            background: rgba(255, 82, 82, 0.4);
            color: white;
            box-shadow: 0 0 8px rgba(255, 82, 82, 0.5);
        }
        /* MODIFIED: Transaction Item Layout */
        .transaction-item {
            /* No longer flex, elements will stack */
        }
        .sui-list-item .amount-display {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* --- Touch Effect --- */
        .touch-particle {
            position: absolute;
            pointer-events: none;
            z-index: 9999;
            color: white;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.9), 0 0 16px rgba(255, 255, 255, 0.7);
            will-change: transform, opacity;
            transform: translate(-50%, -50%);
        }
        .love-particle {
            font-size: 18px; /* Adjusted size for the full word */
            animation: fade-out-love 0.8s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .trail-particle {
            font-size: 14px; /* Smaller size for the trail */
            animation: fade-out-trail 0.6s forwards ease-out;
        }
        @keyframes fade-out-love {
            from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -80%) scale(1.5); }
        }
        @keyframes fade-out-trail {
            from { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -150%) scale(0.8); }
        }

        /* --- NEW: Chat Feature Styles --- */
        #multifunction-menu {
            transition: all 0.3s ease-in-out;
            transform-origin: bottom;
        }
        .multifunction-btn {
            background: var(--glass-container-bg);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 9999px;
            width: 48px; height: 48px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }
        .multifunction-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .multifunction-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            background: rgba(255, 255, 255, 0.05);
        }

        .transfer-bubble {
            width: 240px;
            padding: 0;
            background: linear-gradient(135deg, #f9a825, #f57c00);
            color: white;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
        }
        .transfer-bubble.ai { border-radius: 12px 12px 12px 0; }
        .transfer-bubble.user { border-radius: 12px 12px 0 12px; }
        .transfer-content { padding: 12px; display: flex; align-items: center; gap: 12px; }
        .transfer-content .fa-money-bill-transfer { font-size: 24px; }
        .transfer-info h4 { font-weight: bold; font-size: 1rem; }
        .transfer-info p { font-size: 0.8rem; opacity: 0.9; }
        .transfer-footer { font-size: 0.75rem; padding: 4px 12px; background: rgba(0,0,0,0.1); }
        .transfer-bubble.received, .transfer-bubble.returned {
            background: linear-gradient(135deg, #78909c, #546e7a);
        }

        .voice-bubble {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0.6rem 0.9rem;
        }
        .voice-bubble .fa-play-circle { font-size: 1.2rem; }
        .voice-bubble .voice-duration { font-weight: 500; }
        .voice-transcript {
            font-size: 0.8rem;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0,0,0,0.1);
            color: var(--ai-bubble-text);
            opacity: 0.8;
        }
        .message-bubble.user .voice-transcript {
            border-top: 1px solid rgba(255,255,255,0.2);
            color: var(--user-bubble-text);
        }

        .sticker-bubble {
            background: transparent;
            padding: 0;
            box-shadow: none;
            max-width: 120px;
        }
        .sticker-bubble img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
        .html-bubble {
    padding: 0;
    overflow: hidden; /* 防止内部元素溢出影响布局 */
    background: transparent; /* 使气泡背景透明，让内部HTML完全控制外观 */
    box-shadow: none; /* 移除默认阴影，让内部HTML控制自己的阴影 */
}
        #sticker-drawer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            z-index: 20;
            padding: 1rem;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
        }
        #sticker-drawer.open {
            transform: translateY(0);
        }
        .sticker-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        .sticker-item {
            position: relative;
            cursor: pointer;
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }
        .sticker-item img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
        .sticker-item-delete {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            border: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .sticker-item:hover .sticker-item-delete {
            opacity: 1;
        }
        /* --- 缩小多功能菜单 (新版) --- */

        /* 缩小菜单里每个按钮的大小和图标大小 */
        #multifunction-menu button {
            padding: 0.5rem;      /* 减小按钮的内边距，让它变小 (原 p-3) */
            font-size: 1.125rem;  /* 减小图标的大小 (原 text-2xl) */
        }

        /* 缩小整个菜单框的内边距 */
        #multifunction-menu .glass-container {
            padding: 0.25rem;     /* (原 p-2) */
        }

        /* --- NEW: Story Mode & System Message Styles --- */
        #chat-page.story-mode .chat-header {
            background-color: transparent;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }
        #chat-history.story-mode {
            padding: 1rem;
            display: block; /* Override flex display */
        }
        .story-block {
            margin-bottom: 1.2em;
            line-height: 1.75;
            color: var(--text-color);
            font-size: 0.95rem;
            cursor: default;
        }
        .story-block p {
            margin: 0;
            padding: 0;
        }
        .story-block strong {
            font-weight: bold;
        }
        .system-message-wrapper {
            width: 100%;
            text-align: center;
            margin: 0.5rem 0;
        }
        .system-message-text {
            display: inline-block;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            opacity: 0.7;
            font-size: 0.75rem;
            padding: 0.2rem 0.6rem;
            border-radius: 9999px;
        }
        /* --- NEW: Story Mode Active Styling --- */
        .story-block {
padding: 12px 16px;
    width: 100%;
    font-size: 16px;
    line-height: 1.6;
    color: var(--text-color); /* 修正：使用全局文字颜色变量 */
    border-left: 3px solid rgba(75, 85, 99, 0.7); 
    margin-bottom: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
}
        .story-block:hover {
            background-color: rgba(255, 255, 255, 0.08);
        }
        .story-block p {
            margin: 0;
            padding: 0;
        }
        .story-block strong {
            color: #000000; /* 玩家名字高亮 */
        }
        .story-mode-active {
            /* 剧情模式激活时，整个聊天背景可以变得更暗或不同 */
            /* background-color: #1a1a1b; */ /* 可选：改变背景色 */
        }
        .image-bubble {
        background: transparent;
        padding: 0;
        box-shadow: none;
        max-width: 60%; /* 限制图片最大宽度 */
        border-radius: 12px;
        overflow: hidden; /* 确保图片遵循圆角 */
    }
    .image-bubble img {
        max-width: 100%;
        height: auto;
        display: block; /* 移除图片下方的空隙 */
        cursor: pointer; /* 提示用户图片可点击 */
    }
    </style>
</head>
<body>
    <div class="phone-wrapper">
        <div id="phone-frame">
            <div id="phone-screen">
                <div id="app" class="container">
                    <!-- 主页 -->
                    <div id="home-page" class="w-full h-full flex flex-col p-6 transition-all duration-500 relative">
                        <button id="sui-btn" title="核心监控">SUI</button>
                        
                        <div class="datetime-display">
                            <div id="time-display" class="time">00:00:00</div>
                            <div class="flex items-center gap-4">
                                <div id="date-display" class="date">0000年00月00日 星期X</div>
                                <button id="diary-btn" title="TA的日记">
                                    <i class="fa-solid fa-feather-pointed"></i>
                                </button>
                            </div>
                        </div>
                        
                        <div id="home-content-wrapper" class="w-full flex-1 flex items-center mt-24">
                            <div id="home-avatar-section" class="w-1/2 flex flex-col items-start">
                                <div id="avatar-container" class="relative rounded-full p-1 cursor-pointer w-32 h-32 flex items-center justify-center mb-4">
                                    <img id="avatar-frame" src="" alt="" class="absolute inset-0 w-full h-full object-contain pointer-events-none z-10">
                                    <img id="avatar-img" src="https://placehold.co/120x120/334155/FFFFFF?text=头像" alt="Avatar" class="w-28 h-28 object-cover rounded-full">
                                </div>
                                <input type="file" id="avatar-upload" accept="image/*" class="hidden">
                                <h2 id="signature" class="text-xs font-semibold tracking-wide">个性签名</h2>
                            </div>
                            <div id="home-buttons-section" class="w-1/2 flex flex-col items-end space-y-4">
                                <button id="strategy-btn" class="menu-btn">攻略</button>
                                <button id="memory-btn" class="menu-btn">记忆</button>
                                <button id="role-btn" class="menu-btn">角色</button>
                                <button id="settings-btn" class="menu-btn">设置</button>
                            </div>
                        </div>

                        <!-- Mini Music Player -->
                        <div class="mini-player-container">
                            <div class="mini-player">
                                <audio id="main-audio"></audio>
                                <div class="player-header">
                                    <h2>迷你音乐</h2>
                                    <label for="file-input" class="import-btn">
                                        <i class="fas fa-file-audio"></i> 导入
                                    </label>
                                    <input type="file" id="file-input" class="file-input" accept="audio/*" multiple>
                                </div>
                                <div class="player-content">
                                    <div class="info-section">
                                        <div class="song-info">
                                            <h3 id="song-title">选择一首歌曲</h3>
                                            <p id="song-artist">未知艺术家</p>
                                        </div>
                                        <div class="progress-area">
                                            <div class="progress-container">
                                                <div class="progress-bar"></div>
                                            </div>
                                            <div class="progress-time">
                                                <span id="current-time">0:00</span>
                                                <span id="total-time">0:00</span>
                                            </div>
                                        </div>
                                        <div class="controls">
                                            <button class="control-btn" id="prev"><i class="fas fa-step-backward"></i></button>
                                            <button class="control-btn play-pause" id="play-pause"><i class="fas fa-play"></i></button>
                                            <button class="control-btn" id="next"><i class="fas fa-step-forward"></i></button>
                                            <div class="volume-container">
                                                <i class="fas fa-volume-up"></i>
                                                <input type="range" class="volume-slider" id="volume" min="0" max="1" step="0.01" value="0.7">
                                            </div>
                                            <button class="playlist-btn" id="toggle-playlist"><i class="fas fa-list"></i></button>
                                        </div>
                                    </div>
                                    <label for="cover-input" class="album-art" id="album-art-label">
                                        <i class="fas fa-music"></i>
                                    </label>
                                    <input type="file" id="cover-input" class="cover-input" accept="image/*">
                                </div>
                                <div class="song-list scrollable-content" id="playlist"></div>
                            </div>
                        </div>
                    </div>

                    <!-- 聊天界面 -->
                    <div id="chat-page" class="hidden w-full h-full flex flex-col transition-all duration-500 relative">
                        <div class="chat-header glass-container border-none rounded-b-2xl no-blur">
                            <div class="flex items-center justify-between">
                                <button id="chat-back-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                                <span id="affinity-display" class="text-lg font-semibold">好感度：0/100</span>
                                <div class="flex items-center space-x-2">
                                    <button id="restart-chat-btn" title="新对话" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 00-1 1v4H5a1 1 0 100 2h4v4a1 1 0 102 0v-4h4a1 1 0 100-2h-4V4a1 1 0 00-1-1z" clip-rule="evenodd" /></svg></button>
                                    <button id="summarize-memory-btn" title="存档记忆" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v12l-3-3-3 3V4z" /></svg></button>
                                </div>
                            </div>
                        </div>
                        <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 flex flex-col scrollable-content"></div>
                        
                        <!-- NEW: Multifunction Menu -->
                        <div id="multifunction-menu" class="px-4 pb-2 hidden">
                            <div class="glass-container p-2 rounded-xl">
                                <div class="flex justify-around items-center">
                                    <button id="transfer-btn" class="p-3 text-2xl hover:bg-white/10 rounded-lg" title="转账"><i class="fas fa-money-bill-wave"></i></button>
                                    <button id="voice-mode-btn" class="p-3 text-2xl hover:bg-white/10 rounded-lg" title="语音模式"><i class="fas fa-microphone"></i></button>
                                    <button id="sticker-panel-btn" class="p-3 text-2xl hover:bg-white/10 rounded-lg" title="表情包"><i class="fas fa-grin-alt"></i></button>
                                    <button id="image-btn" class="p-3 text-2xl hover:bg-white/10 rounded-lg" title="发送图片"><i class="fas fa-image"></i></button>
                                    <button id="story-mode-btn" class="p-3 text-2xl hover:bg-white/10 rounded-lg" title="剧情模式"><i class="fas fa-book-open"></i></button>
                                </div>
                            </div>
                        </div>

                        <div id="chat-footer" class="chat-footer">
                            <div class="flex items-center space-x-2">
                                <button id="ai-reply-btn" class="px-4 py-3 rounded-xl glass-container font-bold hover:bg-white/20 transition-colors">角色回复</button>
                                <button id="multifunction-toggle-btn" class="p-3 rounded-full glass-container hover:bg-white/20 transition-colors"><i class="fas fa-plus"></i></button>
                                <div class="flex-1 relative flex items-end">
                                    <textarea id="user-input" class="w-full p-3 pr-12 rounded-2xl glass-container border-none outline-none placeholder-gray-300 focus:ring-2 focus:ring-blue-400 transition-all duration-300 resize-none" placeholder="请输入消息..." rows="1" style="max-height: 120px;"></textarea>
                                     <button id="send-btn" class="absolute right-2 bottom-2 p-2.5 text-pink-300 hover:text-pink-400 transition-colors duration-300 flex items-center justify-center">
    <i class="fas fa-heart"></i>
</button>
                                </div>
                            </div>
                        </div>
                        <div id="chat-batch-actions" class="batch-actions-footer hidden">
                            <div class="flex w-full space-x-2">
                                <button id="confirm-batch-delete-chat-btn" class="w-full p-3 rounded-md bg-red-600 text-white font-bold hover:bg-red-700 transition-colors">删除选中</button>
                                <button id="cancel-batch-delete-chat-btn" class="w-full p-3 rounded-md bg-gray-600 text-white font-bold hover:bg-gray-700 transition-colors">取消</button>
                            </div>
                        </div>

                        <!-- NEW: Sticker Drawer -->
                        <div id="sticker-drawer" class="scrollable-content">
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="font-bold">表情包</h3>
                                <div>
                                    <button id="add-sticker-btn" class="px-3 py-1 text-sm bg-blue-500 rounded-full mr-2">添加</button>
                                    <button id="close-sticker-drawer-btn" class="px-3 py-1 text-sm bg-gray-600 rounded-full">关闭</button>
                                </div>
                            </div>
                            <div id="sticker-grid" class="sticker-grid scrollable-content">
                                <!-- Stickers will be populated here -->
                            </div>
                            <input type="file" id="sticker-upload-input" class="hidden" accept="image/*">
                        </div>
                    </div>
                    
                    <!-- 角色设置页面 -->
                    <div id="role-page" class="hidden w-full h-full flex flex-col p-4 overflow-y-auto scrollable-content">
                        <div class="flex items-center justify-between w-full max-w-lg mx-auto mb-4">
                             <button id="role-back-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                            <h1 class="text-2xl font-bold">角色设置</h1>
                            <div class="w-8"></div>
                        </div>
                        <div class="w-full max-w-lg mx-auto space-y-4 pb-8">
                            <div class="glass-container p-4 rounded-xl">
                                <h2 class="text-xl font-bold mb-3">玩家人设</h2>
                                <input type="text" id="player-name" class="w-full p-3 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="玩家名称">
                                <input type="text" id="player-gender" class="w-full p-3 mt-2 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="玩家性别">
                                <textarea id="player-persona" class="w-full p-3 mt-2 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none h-24 focus:ring-2 focus:ring-blue-400" placeholder="玩家详细人设、背景故事、性格特点..."></textarea>
                            </div>
                             <div class="glass-container p-4 rounded-xl">
                                <h2 class="text-xl font-bold mb-3">攻略角色人设</h2>
                                <input type="text" id="role-name" class="w-full p-3 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="攻略角色名称">
                                <input type="text" id="role-gender" class="w-full p-3 mt-2 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="攻略角色性别">
                                <textarea id="role-persona" class="w-full p-3 mt-2 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none h-32 focus:ring-2 focus:ring-blue-400" placeholder="角色详细人设、背景故事、性格特点..."></textarea>
                            </div>
                             <div class="glass-container p-4 rounded-xl">
                                <h2 class="text-xl font-bold mb-3">AI行为指令</h2>
                                <textarea id="prompt-instructions" class="w-full p-3 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none h-32 focus:ring-2 focus:ring-blue-400" placeholder="给AI的特殊指令, 例如：'请以口语化的方式回复' 或 '在回复中加入表情符号'"></textarea>
                            </div>
                            <button id="save-role-btn" class="w-full p-3 rounded-md bg-indigo-600 text-white font-bold hover:bg-indigo-700 transition-colors duration-300">保存角色设置</button>
                        </div>
                    </div>

                    <!-- 设置页面 -->
                    <div id="settings-page" class="hidden w-full h-full flex-col p-4 overflow-y-auto scrollable-content">
                         <div class="flex items-center justify-between w-full max-w-lg mx-auto mb-4">
                             <button id="settings-back-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                            <h1 class="text-2xl font-bold">设置</h1>
                            <div class="w-8"></div>
                        </div>
                        <div class="glass-container p-6 w-full max-w-lg mx-auto space-y-4">
                            <div class="flex flex-col">
                                <label for="signature-input" class="mb-2">个性签名</label>
                                <input type="text" id="signature-input" class="w-full p-3 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none" placeholder="请输入个性签名...">
                            </div>
                            <div class="mt-6 pt-6 border-t border-white/20">
                                <h2 class="text-xl font-bold mb-4">外观设置</h2>
                                <div class="flex space-x-2">
                                    <button id="avatar-frame-upload-btn" class="flex-grow p-3 rounded-md bg-blue-600 text-white font-bold hover:bg-blue-700 transition-colors duration-300">
                                        选择头像框
                                    </button>
                                    <button id="bg-upload-btn" class="flex-grow p-3 rounded-md bg-blue-600 text-white font-bold hover:bg-blue-700 transition-colors duration-300">
                                        选择背景图片
                                    </button>
                                    <button id="restore-appearance-btn" title="还原默认" class="p-3 rounded-md bg-gray-600 text-white font-bold hover:bg-gray-700 transition-colors duration-300">
                                        <i class="fas fa-undo"></i>
                                    </button>
                                 </div>
                                 <div class="mt-4">
                                    <button id="fullscreen-btn" class="w-full p-3 rounded-md bg-teal-600 text-white font-bold hover:bg-teal-700 transition-colors duration-300 flex items-center justify-center gap-2">
                                        <i class="fas fa-expand"></i>
                                        <span>全屏</span>
                                    </button>
                                </div>
                             </div>
                             <div class="mt-6 pt-6 border-t border-white/20">
                                <h2 class="text-xl font-bold mb-4">字体设置</h2>
                                <div class="flex flex-col mb-2">
                                    <label for="font-upload" class="mb-2">上传自定义字体</label>
                                    <input type="file" id="font-upload" accept=".ttf,.otf,.woff,.woff2" class="w-full p-3 rounded-md bg-white/20 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                                </div>
                                <div class="flex space-x-2 mb-2">
                                    <button id="manage-fonts-btn" class="flex-grow p-2 rounded-md bg-gray-600 text-white text-sm font-bold hover:bg-gray-700 transition-colors">管理字体</button>
                                </div>
                                <div class="flex items-center justify-between mb-2">
                                    <label for="font-family-select">选择字体</label>
                                    <select id="font-family-select" class="w-48 p-2 rounded-md bg-white/20">
                                        <option value="'Inter', sans-serif">默认字体 (Inter)</option>
                                        <option value="'Arial', sans-serif">Arial</option>
                                        <option value="'Times New Roman', serif">Times New Roman</option>
                                        <option value="'Courier New', monospace">Courier New</option>
                                        <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                                    </select>
                                </div>
                             </div>
                             <div class="mt-6 pt-6 border-t border-white/20">
                                <h2 class="text-xl font-bold mb-4">主题设置</h2>
                                <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                                    <div class="flex items-center justify-between"><label for="theme-bg-color">背景色</label><input type="color" id="theme-bg-color" class="w-12 h-8 rounded-md bg-transparent border-none"></div>
                                    <div class="flex items-center justify-between"><label for="theme-text-color">文字颜色</label><input type="color" id="theme-text-color" class="w-12 h-8 rounded-md bg-transparent border-none"></div>
                                    <div class="flex items-center justify-between"><label for="theme-glass-bg">玻璃容器</label><input type="color" id="theme-glass-bg" class="w-12 h-8 rounded-md bg-transparent border-none"></div>
                                    <div class="flex items-center justify-between"><label for="theme-user-bubble">用户气泡</label><input type="color" id="theme-user-bubble" class="w-12 h-8 rounded-md bg-transparent border-none"></div>
                                    <div class="flex items-center justify-between"><label for="theme-ai-bubble">AI气泡</label><input type="color" id="theme-ai-bubble" class="w-12 h-8 rounded-md bg-transparent border-none"></div>
                                    <div class="flex items-center justify-between"><label for="theme-user-text">用户文字</label><input type="color" id="theme-user-text" class="w-12 h-8 rounded-md bg-transparent border-none"></div>
                                    <div class="flex items-center justify-between"><label for="theme-ai-text">AI文字</label><input type="color" id="theme-ai-text" class="w-12 h-8 rounded-md bg-transparent border-none"></div>
                                </div>
                             </div>
                            <div class="mt-6 pt-6 border-t border-white/20">
                                <h2 class="text-xl font-bold mb-4">API 设置</h2>
                                <input type="text" id="api-baseurl" class="w-full p-3 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none" placeholder="API Base URL (例如: https://api.openai.com/v1)">
                                <input type="text" id="api-key" class="w-full p-3 mt-2 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none" placeholder="API 密钥">
                                <input type="text" id="api-model" class="w-full p-3 mt-2 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none" placeholder="模型名称 (例如: gpt-3.5-turbo)">
                                <input type="number" id="api-max-context" class="w-full p-3 mt-2 rounded-md bg-white/20 placeholder-gray-300 focus:outline-none" placeholder="最大上下文消息数 (建议 20)">
                            </div>
                            <div class="mt-6 pt-6 border-t border-white/20">
                                <h2 class="text-xl font-bold mb-4">数据管理</h2>
                                <div class="flex space-x-4">
                                    <button id="export-data-btn" class="w-full p-3 rounded-md bg-green-600 text-white font-bold hover:bg-green-700 transition-colors duration-300">导出数据</button>
                                    <button id="import-data-btn" class="w-full p-3 rounded-md bg-yellow-600 text-white font-bold hover:bg-yellow-700 transition-colors duration-300">导入数据</button>
                                </div>
                                <input type="file" id="import-file-input" class="hidden" accept=".json">
                                <input type="file" id="image-upload-input" class="hidden" accept="image/*">
                            </div>
                            <button id="save-settings-btn" class="w-full p-3 rounded-md bg-indigo-600 text-white font-bold hover:bg-indigo-700 transition-colors duration-300 mt-4">保存所有设置</button>
                        </div>
                    </div>
                    
                    <!-- 记忆页面 -->
                    <div id="memory-page" class="hidden w-full h-full flex flex-col p-4">
                        <div class="flex items-center justify-between w-full max-w-lg mx-auto mb-4">
                             <button id="memory-back-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                            <h1 class="text-2xl font-bold">记忆存档</h1>
                            <div class="flex items-center space-x-2">
                                <button id="batch-delete-memories-btn" title="批量删除" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><i class="fas fa-trash-alt"></i></button>
                                <button id="add-memory-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 00-1 1v4H5a1 1 0 100 2h4v4a1 1 0 102 0v-4h4a1 1 0 100-2h-4V4a1 1 0 00-1-1z" clip-rule="evenodd" /></svg></button>
                            </div>
                        </div>
                        <div id="memory-list" class="glass-container p-4 w-full max-w-lg mx-auto flex-1 overflow-y-auto space-y-2 scrollable-content"></div>
                        <div id="memory-batch-actions" class="hidden w-full max-w-lg mx-auto mt-4 flex space-x-2">
                            <button id="confirm-batch-delete-memories-btn" class="w-full p-3 rounded-md bg-red-600 text-white font-bold hover:bg-red-700 transition-colors">删除选中</button>
                            <button id="cancel-batch-delete-memories-btn" class="w-full p-3 rounded-md bg-gray-600 text-white font-bold hover:bg-gray-700 transition-colors">取消</button>
                        </div>
                    </div>

                    <!-- 日记页面 -->
                    <div id="diary-page" class="hidden w-full h-full flex flex-col p-4">
                        <div class="flex items-center justify-between w-full max-w-2xl mx-auto mb-4">
                            <button id="diary-back-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                            <h1 class="text-2xl font-bold">TA的日记</h1>
                            <div class="flex items-center space-x-2">
                                <button id="generate-diary-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300" title="生成新日记"><i class="fas fa-pen-nib"></i></button>
                                <button id="batch-delete-diaries-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300" title="批量删除"><i class="fas fa-trash-alt"></i></button>
                            </div>
                        </div>
                        <div id="diary-list-container" class="glass-container p-4 w-full max-w-2xl mx-auto flex-1 overflow-y-auto space-y-4 scrollable-content"></div>
                        <div id="diary-batch-actions" class="hidden w-full max-w-2xl mx-auto mt-4 flex space-x-2">
                            <button id="confirm-batch-delete-diaries-btn" class="w-full p-3 rounded-md bg-red-600 text-white font-bold hover:bg-red-700 transition-colors">删除选中</button>
                            <button id="cancel-batch-delete-btn" class="w-full p-3 rounded-md bg-gray-600 text-white font-bold hover:bg-gray-700 transition-colors">取消</button>
                        </div>
                    </div>

                    <!-- SUI 核心监控页面 -->
                    <div id="sui-page" class="hidden w-full h-full flex flex-col p-4">
                        <div class="flex items-center justify-between w-full max-w-2xl mx-auto mb-4">
                            <button id="sui-back-btn" class="p-2 rounded-full hover:bg-white/10 transition-colors duration-300"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                            <h1 class="text-2xl font-bold">核心监控</h1>
                            <div class="w-8"></div> <!-- Placeholder for alignment -->
                        </div>
                        
                        <!-- SUI Navigation Tabs -->
                        <div id="sui-nav" class="w-full max-w-2xl mx-auto flex mb-4 border-b border-white/20">
                            <button data-target="sui-account-section" class="sui-nav-btn flex-1 py-2 text-center font-semibold transition-colors duration-300 active">账户信息</button>
                            <button data-target="sui-comms-section" class="sui-nav-btn flex-1 py-2 text-center font-semibold transition-colors duration-300">外部通讯</button>
                            <button data-target="sui-browsing-section" class="sui-nav-btn flex-1 py-2 text-center font-semibold transition-colors duration-300">浏览记录</button>
                        </div>

                        <!-- SUI Content Sections -->
                        <div id="sui-content-container" class="w-full max-w-2xl mx-auto flex-1 overflow-y-auto scrollable-content">
                            <!-- Account Section -->
                            <div id="sui-account-section" class="sui-content-section">
                                <div class="sui-section">
                                    <div class="flex justify-between items-center mb-3">
                                        <h2 class="text-xl font-bold">账户详情</h2>
                                        <button id="sui-clear-account-btn" class="sui-section-clear-btn"><i class="fas fa-broom"></i> 清空</button>
                                    </div>
                                    <p class="mb-2">当前余额: <span id="sui-balance" class="font-mono text-lg text-amber-300">0.00</span></p>
                                    <h3 class="text-md font-semibold mb-2 border-t border-white/10 pt-2">交易记录</h3>
                                    <div id="sui-transactions-list" class="sui-list">
                                        <p class="opacity-70 text-center">暂无记录</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Comms Section -->
                            <div id="sui-comms-section" class="sui-content-section hidden">
                                <div class="sui-section">
                                    <div class="flex justify-between items-center mb-3">
                                        <h2 class="text-xl font-bold">外部通讯</h2>
                                        <button id="sui-clear-comms-btn" class="sui-section-clear-btn"><i class="fas fa-broom"></i> 清空</button>
                                    </div>
                                    <div id="sui-other-chats-list" class="sui-list">
                                        <p class="opacity-70 text-center">暂无记录</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Browsing Section -->
                            <div id="sui-browsing-section" class="sui-content-section hidden">
                                <div class="sui-section">
                                    <div class="flex justify-between items-center mb-3">
                                        <h2 class="text-xl font-bold">浏览记录</h2>
                                        <button id="sui-clear-browsing-btn" class="sui-section-clear-btn"><i class="fas fa-broom"></i> 清空</button>
                                    </div>
                                    <div id="sui-browsing-history-list" class="sui-list">
                                        <p class="opacity-70 text-center">暂无记录</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- 自定义弹窗 -->
                    <div id="custom-dialog" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
                        <div class="glass-container p-6 shadow-xl w-full max-w-sm border-none">
                            <h3 id="dialog-title" class="text-xl font-bold mb-4"></h3>
                            <div id="dialog-message" class="mb-4"></div>
                            <div id="dialog-input-container" class="mb-4 hidden">
                                <textarea id="dialog-input" class="w-full p-2 border-none rounded-md bg-white/20 h-24"></textarea>
                            </div>
                            <!-- NEW: Container for complex dialog inputs -->
                            <div id="dialog-complex-input-container" class="mb-4 hidden"></div>
                            <div id="dialog-buttons" class="flex justify-end space-x-2"></div>
                        </div>
                    </div>
                    <input type="file" id="bg-upload-input" accept="image/*" class="hidden">
                    <input type="file" id="avatar-frame-upload-input" accept="image/*" class="hidden">
                </div>
            </div>
        </div>
    </div>

    
<script>
    (async () => { // Wrap in an async IIFE to use top-level await
        const get = id => document.getElementById(id);
        
        const UILock = {
            _locked: false,
            _timeout: null,
            lock: function(duration = 500) {
                this._locked = true;
                clearTimeout(this._timeout);
                this._timeout = setTimeout(() => {
                    this._locked = false;
                }, duration);
            },
            isLocked: function() {
                return this._locked;
            }
        };

        const APP_VERSION = "3.7.0"; // Version with parsing fixes

        // --- IndexedDB Helper ---
        const db = {
            _db: null,
            init: function(dbName, storeNames) {
        return new Promise((resolve, reject) => {
            // 版本号从 2 升级到 3，以触发数据库结构更新
            const request = indexedDB.open(dbName, 3);
            request.onerror = () => reject("IndexedDB error: " + request.error);
            request.onsuccess = (event) => { this._db = event.target.result; resolve(this); };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                storeNames.forEach(storeName => {
                    if (!db.objectStoreNames.contains(storeName)) {
                        db.createObjectStore(storeName);
                    }
                });
            };
        });
    },
            set: function(storeName, key, value) {
                return new Promise((resolve, reject) => {
                    if (!this._db) return reject("DB not initialized");
                    try {
                        const transaction = this._db.transaction([storeName], 'readwrite');
                        const store = transaction.objectStore(storeName);
                        const request = store.put(value, key);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject("Failed to save to DB: " + request.error);
                    } catch (e) { reject(e); }
                });
            },
            get: function(storeName, key) {
                return new Promise((resolve, reject) => {
                    if (!this._db) return reject("DB not initialized");
                    const transaction = this._db.transaction([storeName]);
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject("Failed to get from DB: " + request.error);
                });
            },
            delete: function(storeName, key) {
                return new Promise((resolve, reject) => {
                    if (!this._db) return reject("DB not initialized");
                    const transaction = this._db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject("Failed to delete from DB: " + request.error);
                });
            },
            getAll: function(storeName) {
                return new Promise((resolve, reject) => {
                    if (!this._db) return reject("DB not initialized");
                    const transaction = this._db.transaction([storeName]);
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject("Failed to get all from DB: " + request.error);
                });
            }
        };
        await db.init('GameDataStore', ['assets', 'stickers', 'chatHistory', 'memories', 'diaries', 'suiData']);

        let loadedFontFaces = new Set();

        // Page elements
        const chatPage = get('chat-page');
        const phoneScreen = get('phone-screen');
        const pages = { home: get('home-page'), chat: chatPage, role: get('role-page'), settings: get('settings-page'), memory: get('memory-page'), diary: get('diary-page'), sui: get('sui-page') };

        // Buttons
        const strategyBtn = get('strategy-btn'), memoryBtn = get('memory-btn'), roleBtn = get('role-btn'), settingsBtn = get('settings-btn'), saveRoleBtn = get('save-role-btn'), saveSettingsBtn = get('save-settings-btn');
        const backBtns = document.querySelectorAll('#chat-back-btn, #role-back-btn, #settings-back-btn, #memory-back-btn, #diary-back-btn, #sui-back-btn');
        const exportDataBtn = get('export-data-btn'), importDataBtn = get('import-data-btn'), importFileInput = get('import-file-input'), diaryBtn = get('diary-btn'), suiBtn = get('sui-btn');
        const fullscreenBtn = get('fullscreen-btn');

        // Home page elements
        const avatarContainer = get('avatar-container'), avatarImg = get('avatar-img'), avatarFrame = get('avatar-frame'), avatarUpload = get('avatar-upload');
        const signatureDisplay = get('signature'), timeDisplay = get('time-display'), dateDisplay = get('date-display');

        // Chat elements
        const chatHistory = get('chat-history'), userInput = get('user-input'), sendBtn = get('send-btn'), aiReplyBtn = get('ai-reply-btn');
        const restartChatBtn = get('restart-chat-btn'), summarizeMemoryBtn = get('summarize-memory-btn'), affinityDisplay = get('affinity-display'), chatFooter = get('chat-footer');
        const chatBatchActions = get('chat-batch-actions'), confirmBatchDeleteChatBtn = get('confirm-batch-delete-chat-btn'), cancelBatchDeleteChatBtn = get('cancel-batch-delete-chat-btn');
        let isChatBatchDeleteMode = false;
        const multifunctionToggleBtn = get('multifunction-toggle-btn'), multifunctionMenu = get('multifunction-menu');
        const transferBtn = get('transfer-btn'), voiceModeBtn = get('voice-mode-btn'), stickerPanelBtn = get('sticker-panel-btn'), storyModeBtn = get('story-mode-btn');
        const stickerDrawer = get('sticker-drawer'), stickerGrid = get('sticker-grid'), addStickerBtn = get('add-sticker-btn');
        const stickerUploadInput = get('sticker-upload-input'), closeStickerDrawerBtn = get('close-sticker-drawer-btn');

        // Memory elements
        const memoryListEl = get('memory-list'), addMemoryBtn = get('add-memory-btn'), batchDeleteMemoriesBtn = get('batch-delete-memories-btn');
        const memoryBatchActions = get('memory-batch-actions'), confirmBatchDeleteMemoriesBtn = get('confirm-batch-delete-memories-btn'), cancelBatchDeleteMemoriesBtn = get('cancel-batch-delete-memories-btn');
        let isMemoryBatchDeleteMode = false;
        
        // Diary elements
        const diaryListContainer = get('diary-list-container'), generateDiaryBtn = get('generate-diary-btn'), batchDeleteDiariesBtn = get('batch-delete-diaries-btn');
        const diaryBatchActions = get('diary-batch-actions'), confirmBatchDeleteBtn = get('confirm-batch-delete-diaries-btn'), cancelBatchDeleteBtn = get('cancel-batch-delete-btn');
        let isDiaryBatchDeleteMode = false;

        // SUI elements
        const suiContentContainer = get('sui-content-container');
        let suiBalanceEl = get('sui-balance'), suiTransactionsListEl = get('sui-transactions-list'), suiOtherChatsListEl = get('sui-other-chats-list'), suiBrowsingHistoryListEl = get('sui-browsing-history-list');
        const suiNav = get('sui-nav'), suiNavBtns = document.querySelectorAll('.sui-nav-btn'), suiContentSections = document.querySelectorAll('.sui-content-section');
        const suiClearAccountBtn = get('sui-clear-account-btn'), suiClearCommsBtn = get('sui-clear-comms-btn'), suiClearBrowsingBtn = get('sui-clear-browsing-btn');

        // Dialog elements
        const dialog = get('custom-dialog'), dialogTitle = get('dialog-title'), dialogMessage = get('dialog-message');
        const dialogInputContainer = get('dialog-input-container'), dialogInput = get('dialog-input'), dialogButtons = get('dialog-buttons');
        const dialogComplexInputContainer = get('dialog-complex-input-container');
        
        // Settings Elements
        const themeBgColor = get('theme-bg-color'), themeTextColor = get('theme-text-color'), themeGlassBg = get('theme-glass-bg'), themeUserBubble = get('theme-user-bubble');
        const themeAiBubble = get('theme-ai-bubble'), themeUserText = get('theme-user-text'), themeAiText = get('theme-ai-text');
        const fontUpload = get('font-upload'), fontFamilySelect = get('font-family-select'), manageFontsBtn = get('manage-fonts-btn'), bgUploadBtn = get('bg-upload-btn'), bgUploadInput = get('bg-upload-input');
        const avatarFrameUploadBtn = get('avatar-frame-upload-btn'), avatarFrameUploadInput = get('avatar-frame-upload-input'), restoreAppearanceBtn = get('restore-appearance-btn');
        const apiBaseUrl = get('api-baseurl'), apiKey = get('api-key'), apiModel = get('api-model');

        const state = {
            version: APP_VERSION,
            config: { bgImage: null, avatarImage: null, avatarFrameImage: null, signature: '个性签名', api: { baseUrl: '', key: '', model: '' }, colors: { bgColor: '#1a202c', textColor: '#ffffff', glassBg: 'rgba(255, 255, 255, 0.15)', userBubble: 'rgba(60, 179, 113, 0.7)', userText: '#ffffff', aiBubble: 'rgba(255, 255, 255, 0.8)', aiText: '#000000', }, fontFamily: "'Inter', sans-serif", customFonts: {} },
            role: { playerName: '', playerGender: '', playerPersona: '', roleName: '', roleGender: '', rolePersona: '', promptInstructions: '' },
            chat: { history: [], affinity: 0, sendMode: 'text', mode: 'phone' }, // mode: 'phone' or 'story'
            memories: [],
            diaries: [],
            sui: { isInitialized: false, balance: 0, transactions: [], otherChats: [], browsingHistory: [] },
            music: { playlist: [], currentSongIndex: -1, albumArt: null, volume: 0.7 },
            stickers: [],
            ui: { isFullscreen: false }
        };
        
        const applyColors = (colors) => {
            document.documentElement.style.setProperty('--bg-color', colors.bgColor); document.documentElement.style.setProperty('--text-color', colors.textColor);
            document.documentElement.style.setProperty('--glass-container-bg', colors.glassBg); document.documentElement.style.setProperty('--user-bubble-bg', colors.userBubble);
            document.documentElement.style.setProperty('--user-bubble-text', colors.userText); document.documentElement.style.setProperty('--ai-bubble-bg', colors.aiBubble);
            document.documentElement.style.setProperty('--ai-bubble-text', colors.aiText); phoneScreen.style.backgroundColor = colors.bgColor;
        };
        
        const applyFont = async (fontName) => {
            if (state.config.customFonts[fontName]) {
                if (loadedFontFaces.has(fontName)) {
                    document.documentElement.style.setProperty('--custom-font', `'${fontName}', sans-serif`);
                    return;
                }
                try {
                    const fontData = await db.get('assets', `font-${fontName}`);
                    if (!fontData) throw new Error(`Font data for '${fontName}' not found in DB.`);
                    const fontFace = new FontFace(fontName, `url(${fontData})`);
                    await fontFace.load();
                    document.fonts.add(fontFace);
                    loadedFontFaces.add(fontName);
                    document.documentElement.style.setProperty('--custom-font', `'${fontName}', sans-serif`);
                } catch (error) {
                    console.error('Custom font failed to load:', error);
                    document.documentElement.style.setProperty('--custom-font', "'Inter', sans-serif"); // Fallback
                }
            } else {
                document.documentElement.style.setProperty('--custom-font', fontName);
            }
        };
        
        const renderFontOptions = () => {
            const customFontOptions = fontFamilySelect.querySelectorAll('option.custom-font-option');
            customFontOptions.forEach(opt => opt.remove());

            for (const fontName in state.config.customFonts) {
                const option = document.createElement('option');
                option.value = fontName;
                option.textContent = fontName;
                option.className = 'custom-font-option';
                fontFamilySelect.appendChild(option);
            }
        };

        const ASSET_KEYS = {
            'bgImage': (s) => s.config.bgImage,
            'avatarImage': (s) => s.config.avatarImage,
            'avatarFrameImage': (s) => s.config.avatarFrameImage,
            'albumArt': (s) => s.music.albumArt
        };
        const setAssetValue = (obj, key, value) => {
            if (key === 'albumArt') obj.music.albumArt = value;
            else obj.config[key] = value;
        };

        async function saveState() {
        try {
            state.version = APP_VERSION;
            const stateToSave = JSON.parse(JSON.stringify(state));

            // --- 将大型数据数组存入 IndexedDB ---
            // 我们使用固定的 'main' 作为键，因为每个仓库只存一个完整的数据数组
            await db.set('chatHistory', 'main', state.chat.history);
            await db.set('memories', 'main', state.memories);
            await db.set('diaries', 'main', state.diaries);
            await db.set('suiData', 'main', state.sui);
            
            // --- 从即将存入 localStorage 的对象中删除这些大型数据 ---
            delete stateToSave.chat.history; // 只删除 history，保留 affinity 等其他 chat 配置
            delete stateToSave.memories;
            delete stateToSave.diaries;
            delete stateToSave.sui;

            for (const key in ASSET_KEYS) {
                const assetData = ASSET_KEYS[key](stateToSave);
                if (assetData && assetData.startsWith('data:')) {
                    await db.set('assets', key, assetData);
                    setAssetValue(stateToSave, key, 'indexed');
                } else if (!assetData) {
                    await db.delete('assets', key).catch(e => console.warn(`Could not delete ${key} from DB`, e));
                }
            }

            for (const fontName in stateToSave.config.customFonts) {
                const fontData = stateToSave.config.customFonts[fontName];
                if (fontData && fontData.startsWith('data:')) {
                    await db.set('assets', `font-${fontName}`, fontData);
                    stateToSave.config.customFonts[fontName] = 'indexed';
                }
            }
            
            for (const sticker of state.stickers) {
                await db.set('stickers', sticker.id, sticker);
            }
            delete stateToSave.stickers;

            if (stateToSave.music && stateToSave.music.playlist) {
                stateToSave.music.playlist = stateToSave.music.playlist.map(song => ({ name: song.name }));
            }
            localStorage.setItem('game_state_v5', JSON.stringify(stateToSave));
        } catch (e) {
            console.error("Failed to save state.", e);
            showDialog("保存失败", "数据无法保存，可能是浏览器存储空间已满。");
        }
    };

        async function loadState() {
        let savedState = null;
        try {
            const rawState = localStorage.getItem('game_state_v5');
            if(rawState) savedState = JSON.parse(rawState);
        } catch (e) { 
            console.error("Failed to parse state from localStorage, possibly corrupt data.", e);
            localStorage.removeItem('game_state_v5');
        }

        if (savedState) {
            // Compatibility check for story mode transition
            if (!savedState.chat || typeof savedState.chat.mode === 'undefined') {
                if (savedState.chat) savedState.chat.mode = 'phone';
                else savedState.chat = { history: [], affinity: 0, sendMode: 'text', mode: 'phone' };
            }

            const defaultState = JSON.parse(JSON.stringify(state));
            const mergedState = { ...defaultState, ...savedState };
            mergedState.config = { ...defaultState.config, ...(savedState.config || {}) };
            mergedState.config.colors = { ...defaultState.config.colors, ...(savedState.config?.colors || {}) };
            mergedState.role = { ...defaultState.role, ...(savedState.role || {}) };
            // 注意：不再从 localStorage 合并 sui, memories, diaries, chat.history
            mergedState.music = { ...defaultState.music, ...(savedState.music || {}) };
            mergedState.chat = { ...defaultState.chat, ...(savedState.chat || {}) };
            mergedState.ui = { ...defaultState.ui, ...(savedState.ui || {}) };

            Object.assign(state, mergedState);
        }
        
        // --- 从 IndexedDB 加载大型数据 ---
        // 这样可以确保即使 localStorage 中没有这些数据，也能从 IndexedDB 恢复
        const [chatHistoryData, memoriesData, diariesData, suiData, stickersData] = await Promise.all([
            db.get('chatHistory', 'main'),
            db.get('memories', 'main'),
            db.get('diaries', 'main'),
            db.get('suiData', 'main'),
            db.getAll('stickers')
        ]);
        
        if (chatHistoryData) state.chat.history = chatHistoryData;
        if (memoriesData) state.memories = memoriesData;
        if (diariesData) state.diaries = diariesData;
        if (suiData) state.sui = suiData;
        state.stickers = stickersData || [];


        for (const key in ASSET_KEYS) {
            if (ASSET_KEYS[key](state) === 'indexed') {
                const data = await db.get('assets', key);
                if (data) setAssetValue(state, key, data);
            }
        }
        
        if (state.config.bgImage) phoneScreen.style.backgroundImage = `url(${state.config.bgImage})`;
        if (state.config.avatarImage) avatarImg.src = state.config.avatarImage;
        if (state.config.avatarFrameImage) avatarFrame.src = state.config.avatarFrameImage;
        
        signatureDisplay.textContent = state.config.signature;
        applyColors(state.config.colors);
        renderFontOptions();
        await applyFont(state.config.fontFamily);
        
        if (state.ui.isFullscreen) {
            document.body.classList.add('fullscreen-mode');
            const icon = fullscreenBtn.querySelector('i');
            const text = fullscreenBtn.querySelector('span');
            icon.className = 'fas fa-compress';
            text.textContent = '退出全屏';
        }

        await initMusicPlayer();
        renderChatHistory({ autoScroll: true });
        renderMemoryList();
        renderDiaryList();
        renderSuiPage();
        renderStickerDrawer();
    };

        const showView = (view) => {
            Object.values(pages).forEach(p => p.classList.add('hidden'));
            if(pages[view]) pages[view].classList.remove('hidden');
        };

        const showDialog = (title, message, options = {}) => {
            return new Promise((resolve) => {
                dialogTitle.textContent = title; 
                if (typeof message === 'string') {
                    dialogMessage.innerHTML = message;
                } else {
                    dialogMessage.innerHTML = '';
                    dialogMessage.appendChild(message);
                }
                dialogButtons.innerHTML = '';
                dialogInputContainer.classList.toggle('hidden', !options.input);
                dialogComplexInputContainer.classList.add('hidden');
                dialogComplexInputContainer.innerHTML = '';

                if (options.input) {
                    dialogInput.value = options.defaultValue || '';
                    dialogInput.placeholder = options.placeholder || '';
                }
                if (options.complexInput) {
                    dialogComplexInputContainer.classList.remove('hidden');
                    dialogComplexInputContainer.innerHTML = options.complexInput;
                }

                const buttons = options.buttons || [{ text: '取消', value: false, class: 'bg-gray-500/50' }, { text: '确定', value: true, class: 'bg-blue-500' }];
                buttons.forEach(btnInfo => {
                    const button = document.createElement('button');
                    button.textContent = btnInfo.text;
                    button.className = `px-4 py-2 text-white rounded-md ${btnInfo.class}`;
                    button.onclick = () => {
                        dialog.classList.add('hidden'); dialog.style.display = 'none';
                        let result;
                        if (options.getValues) {
                            result = btnInfo.value === false ? false : options.getValues();
                        } else {
                            result = options.input ? (btnInfo.value === false ? false : dialogInput.value) : btnInfo.value;
                        }
                        resolve(result);
                    };
                    dialogButtons.appendChild(button);
                });
                dialog.classList.remove('hidden'); dialog.style.display = 'flex';
                if (options.input) dialogInput.focus();
                if (options.complexInput) dialogComplexInputContainer.querySelector('input, textarea')?.focus();
            });
        };

        // --- 新的Toast通知队列系统 ---
        
        // 1. 定义队列和状态锁
        let toastQueue = [];
        let isToastActive = false;

        // 2. 创建一个处理器函数，负责按顺序显示队列中的通知
        const processToastQueue = () => {
            // 如果当前已有通知在显示，或者队列为空，则不执行任何操作
            if (isToastActive || toastQueue.length === 0) {
                return;
            }

            // 锁定状态，表示即将显示一个通知
            isToastActive = true;

            // 从队列头部取出第一条消息
            const message = toastQueue.shift();

            const toast = document.createElement('div');
            toast.textContent = message;
            toast.className = 'fixed bottom-20 left-1/2 -translate-x-1/2 bg-black bg-opacity-70 text-white px-4 py-2 rounded-full shadow-lg transition-opacity duration-300 z-[10001] opacity-0';
            document.body.appendChild(toast);

            // Fade-in
            setTimeout(() => toast.classList.remove('opacity-0'), 10);

            // 设置通知显示的总时长
            const displayDuration = 2000; // 显示2秒
            const fadeOutDuration = 300;   // 渐隐动画0.3秒

            // 在显示时间结束后，开始渐隐
            setTimeout(() => {
                toast.classList.add('opacity-0');
                
                // 在渐隐动画结束后，移除元素并处理下一条通知
                setTimeout(() => {
                    toast.remove();
                    isToastActive = false; // 解除锁定
                    processToastQueue();   // 尝试处理队列中的下一条通知
                }, fadeOutDuration);

            }, displayDuration);
        };

        // 3. 改造原始的 showToast 函数，使其只负责将消息推入队列
        const showToast = (message) => {
            // 将新消息添加到队列尾部
            toastQueue.push(message);
            // 每次添加后都尝试启动处理器
            processToastQueue();
        };
        
        const updateDateTime = () => {
            const now = new Date();
            timeDisplay.textContent = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
            dateDisplay.textContent = now.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
        };
        
        updateDateTime(); setInterval(updateDateTime, 1000);

        const initTouchEffects = () => {
            let isDragging = false;
            let letterIndex = 0;
            const letters = ['L', 'O', 'V', 'E'];
            let lastParticleTime = 0;
            const particleInterval = 30;

            const createParticle = (x, y, type) => {
                const particle = document.createElement('div');
                if (type === 'love') {
                    particle.className = 'touch-particle love-particle';
                    particle.textContent = 'LOVE';
                } else {
                    particle.className = 'touch-particle trail-particle';
                    particle.textContent = letters[letterIndex];
                    letterIndex = (letterIndex + 1) % letters.length;
                }
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                phoneScreen.appendChild(particle);
                particle.addEventListener('animationend', () => particle.remove());
            };

            const getCoords = (e) => {
                const rect = phoneScreen.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: clientX - rect.left, y: clientY - rect.top };
            };
            
            const isInteractive = (target) => {
                return target.closest('button, a, input, select, textarea, .message-bubble, .progress-container, .album-art, .song-item, [role="button"], [onclick]');
            };

            const handlePointerDown = (e) => {
                if (isInteractive(e.target)) return;
                isDragging = true;
                const { x, y } = getCoords(e);
                createParticle(x, y, 'love');
            };

            const handlePointerMove = (e) => {
                if (!isDragging) return;
                const now = Date.now();
                if (now - lastParticleTime < particleInterval) return;
                lastParticleTime = now;
                const { x, y } = getCoords(e);
                createParticle(x, y, 'trail');
            };

            const handlePointerUp = () => { isDragging = false; };

            phoneScreen.addEventListener('mousedown', handlePointerDown);
            phoneScreen.addEventListener('mousemove', handlePointerMove);
            window.addEventListener('mouseup', handlePointerUp);
            phoneScreen.addEventListener('touchstart', handlePointerDown);
            phoneScreen.addEventListener('touchmove', handlePointerMove);
            phoneScreen.addEventListener('touchend', handlePointerUp);
            phoneScreen.addEventListener('touchcancel', handlePointerUp);
        };
        
        async function initMusicPlayer() {
            const audio = get('main-audio'), playPauseBtn = get('play-pause'), prevBtn = get('prev'), nextBtn = get('next'), volumeSlider = get('volume');
            const progressContainer = document.querySelector('.progress-container'), progressBar = document.querySelector('.progress-bar');
            const currentTimeEl = get('current-time'), totalTimeEl = get('total-time'), songTitle = get('song-title'), songArtist = get('song-artist');
            const albumArtLabel = get('album-art-label'), fileInput = get('file-input'), coverInput = get('cover-input'), playlistEl = get('playlist'), togglePlaylistBtn = get('toggle-playlist');
            let isPlaying = false;
            let currentBlobUrl = null;

            async function playAudio() {
                if (!audio.src) {
                    showToast('没有可播放的歌曲');
                    return;
                }
                try {
                    await audio.play();
                } catch (error) {
                    console.error("音频播放失败:", error);
                    showToast('播放被浏览器阻止，请尝试与页面交互后再试');
                    isPlaying = false;
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    albumArtLabel.classList.remove('rotating');
                }
            }

            async function prepareSong(index) {
                if (!state.music.playlist || index < 0 || index >= state.music.playlist.length) return false;
                
                if (currentBlobUrl) {
                    URL.revokeObjectURL(currentBlobUrl);
                    currentBlobUrl = null;
                }

                const song = state.music.playlist[index];
                const songDataUrl = await db.get('assets', `music-${song.name}`);

                if (!songDataUrl) {
                    showToast(`歌曲数据丢失: ${song.name}`);
                    songTitle.textContent = song.name;
                    songArtist.textContent = '数据丢失';
                    audio.src = '';
                    return false;
                }

                try {
                    const response = await fetch(songDataUrl);
                    const blob = await response.blob();
                    currentBlobUrl = URL.createObjectURL(blob);
                    audio.src = currentBlobUrl;
                    
                    state.music.currentSongIndex = index;
                    songTitle.textContent = song.name;
                    songArtist.textContent = '本地音乐';
                    playlistEl.querySelectorAll('.song-item').forEach((item, idx) => item.classList.toggle('active', idx === index));
                    await saveState();
                    return true;

                } catch (error) {
                    console.error("创建Blob URL失败:", error);
                    showToast('准备歌曲时发生错误');
                    return false;
                }
            }

            function renderPlaylist() {
                playlistEl.innerHTML = ''; if (!state.music.playlist || state.music.playlist.length === 0) return;
                state.music.playlist.forEach((song, index) => {
                    const songItem = document.createElement('div'); songItem.className = 'song-item'; songItem.textContent = song.name;
                    
                    songItem.addEventListener('click', async () => {
                        const success = await prepareSong(index);
                        if (success) {
                            await playAudio();
                        }
                    });

                    let pressTimer;
                    songItem.addEventListener('mousedown', () => { pressTimer = setTimeout(() => managePlaylistItem(index), 750); });
                    songItem.addEventListener('mouseup', () => clearTimeout(pressTimer));
                    songItem.addEventListener('mouseleave', () => clearTimeout(pressTimer));
                    songItem.addEventListener('touchstart', () => { pressTimer = setTimeout(() => managePlaylistItem(index), 750); }, { passive: true });
                    songItem.addEventListener('touchend', () => clearTimeout(pressTimer));
                    playlistEl.appendChild(songItem);
                });
            }

            async function managePlaylistItem(index) {
                const song = state.music.playlist[index]; if (!song) return;
                const confirmed = await showDialog('管理歌曲', `确定要从列表中移除 "${song.name}" 吗？这会从数据库中删除该歌曲文件。`, { buttons: [{text: '取消', value: false, class: 'bg-gray-500/50'}, {text: '移除', value: true, class: 'bg-red-500/80'}] });
                if (confirmed) {
                    const wasPlayingCurrentSong = (index === state.music.currentSongIndex);
                    const removedSongName = state.music.playlist[index].name;
                    await db.delete('assets', `music-${removedSongName}`);
                    
                    if (index < state.music.currentSongIndex) state.music.currentSongIndex--;
                    
                    state.music.playlist.splice(index, 1);
                    
                    if (wasPlayingCurrentSong) {
                        audio.pause();
                        audio.src = '';
                        if (currentBlobUrl) URL.revokeObjectURL(currentBlobUrl);
                        currentBlobUrl = null;
                        state.music.currentSongIndex = -1;
                        songTitle.textContent = '选择一首歌曲';
                        songArtist.textContent = '未知艺术家';
                        currentTimeEl.textContent = '0:00';
                        totalTimeEl.textContent = '0:00';
                        progressBar.style.width = '0%';
                        albumArtLabel.classList.remove('rotating');
                        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    }
                    
                    await saveState();
                    renderPlaylist();
                    if(state.music.currentSongIndex !== -1) { const activeSongEl = playlistEl.children[state.music.currentSongIndex]; if (activeSongEl) activeSongEl.classList.add('active'); }
                    showToast('歌曲已移除');
                }
            }

            const togglePlay = async () => {
                if (audio.paused) {
                    if (!audio.src) {
                        if (state.music.playlist.length === 0) { showToast('请先导入音乐'); fileInput.click(); return; }
                        const indexToPlay = state.music.currentSongIndex !== -1 ? state.music.currentSongIndex : 0;
                        const success = await prepareSong(indexToPlay);
                        if (success) await playAudio();
                    } else {
                        await playAudio();
                    }
                } else {
                    audio.pause();
                }
            };

            const prevSong = async () => {
                if (state.music.playlist.length === 0) return;
                const newIndex = (state.music.currentSongIndex - 1 + state.music.playlist.length) % state.music.playlist.length;
                if (await prepareSong(newIndex)) {
                    await playAudio();
                }
            };

            const nextSong = async () => {
                if (state.music.playlist.length === 0) return;
                const newIndex = (state.music.currentSongIndex + 1) % state.music.playlist.length;
                if (await prepareSong(newIndex)) {
                    await playAudio();
                }
            };

            audio.onplay = () => { isPlaying = true; playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>'; albumArtLabel.classList.add('rotating'); };
            audio.onpause = () => { isPlaying = false; playPauseBtn.innerHTML = '<i class="fas fa-play"></i>'; albumArtLabel.classList.remove('rotating'); };
            audio.onended = nextSong;
            audio.ontimeupdate = () => { const { currentTime, duration } = audio; if (duration) { progressBar.style.width = `${(currentTime / duration) * 100}%`; currentTimeEl.textContent = formatTime(currentTime); } };
            audio.ondurationchange = () => { totalTimeEl.textContent = formatTime(audio.duration); };
            
            function setProgress(e) { if (state.music.playlist.length === 0 || !audio.duration) return; audio.currentTime = (e.offsetX / this.clientWidth) * audio.duration; }
            function formatTime(seconds) { if (isNaN(seconds)) return '0:00'; const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${minutes}:${secs < 10 ? '0' : ''}${secs}`; }
            const setVolume = async () => { audio.volume = volumeSlider.value; state.music.volume = audio.volume; await saveState(); };

            async function handleFileSelect(e) {
                const files = Array.from(e.target.files); if (files.length === 0) return; showToast(`正在处理 ${files.length} 首歌曲...`);
                let firstNewSongIndex = -1;
                for (const file of files) {
                    const songName = file.name.replace(/\.[^/.]+$/, ""); const reader = new FileReader();
                    const promise = new Promise((resolve, reject) => {
                        reader.onload = async (event) => {
                            try { const dataUrl = event.target.result; await db.set('assets', `music-${songName}`, dataUrl); const existingSongIndex = state.music.playlist.findIndex(s => s.name === songName); if (existingSongIndex === -1) { state.music.playlist.push({ name: songName }); if (firstNewSongIndex === -1) { firstNewSongIndex = state.music.playlist.length - 1; } } resolve(); } catch (err) { reject(err); }
                        };
                        reader.onerror = reject; reader.readAsDataURL(file);
                    });
                    await promise;
                }
                renderPlaylist(); showToast('歌曲处理完成！');
                if (!isPlaying && firstNewSongIndex !== -1) {
                    if (await prepareSong(firstNewSongIndex)) {
                        await playAudio();
                    }
                }
                await saveState();
            }

            async function handleCoverSelect(e) {
                const file = e.target.files[0]; if (!file || !file.type.match('image.*')) return; const reader = new FileReader();
                reader.onload = async event => { const dataUrl = event.target.result; state.music.albumArt = dataUrl; albumArtLabel.innerHTML = `<img src="${dataUrl}" alt="album art">`; await saveState(); };
                reader.readAsDataURL(file);
            }

            renderPlaylist(); 
            if (state.music.albumArt) albumArtLabel.innerHTML = `<img src="${state.music.albumArt}" alt="album art">`;
            volumeSlider.value = state.music.volume; audio.volume = state.music.volume;
            
            if (state.music.currentSongIndex > -1 && state.music.playlist.length > state.music.currentSongIndex) {
                await prepareSong(state.music.currentSongIndex);
            }

            playPauseBtn.addEventListener('click', togglePlay); prevBtn.addEventListener('click', prevSong); nextBtn.addEventListener('click', nextSong);
            progressContainer.addEventListener('click', setProgress); volumeSlider.addEventListener('input', setVolume);
            fileInput.addEventListener('change', handleFileSelect); coverInput.addEventListener('change', handleCoverSelect);
            togglePlaylistBtn.addEventListener('click', () => { playlistEl.style.display = (playlistEl.style.display === 'block') ? 'none' : 'block'; });
        }

        // --- Navigation & Page Setup ---
        strategyBtn.addEventListener('click', () => { showView('chat'); setTimeout(() => { chatHistory.scrollTop = chatHistory.scrollHeight; }, 0); });
        memoryBtn.addEventListener('click', () => { renderMemoryList(); showView('memory'); });
        diaryBtn.addEventListener('click', () => { renderDiaryList(); showView('diary'); });
        suiBtn.addEventListener('click', () => {
            try {
                renderSuiPage();
                suiNavBtns.forEach((btn, index) => btn.classList.toggle('active', index === 0));
                suiContentSections.forEach((section, index) => section.classList.toggle('hidden', index !== 0));
                showView('sui');
            } catch (e) {
                console.error("Error opening SUI page:", e);
                showDialog("页面错误", "无法打开核心监控页面，可能存在损坏的数据。错误详情已记录在控制台。");
            }
        });
        roleBtn.addEventListener('click', () => { get('player-name').value = state.role.playerName; get('player-gender').value = state.role.playerGender; get('player-persona').value = state.role.playerPersona; get('role-name').value = state.role.roleName; get('role-gender').value = state.role.roleGender; get('role-persona').value = state.role.rolePersona; get('prompt-instructions').value = state.role.promptInstructions; showView('role'); });
        settingsBtn.addEventListener('click', () => { 
            get('signature-input').value = state.config.signature; 
            apiBaseUrl.value = state.config.api.baseUrl; 
            apiKey.value = state.config.api.key; 
            apiModel.value = state.config.api.model; 
            // --- 新增代码 ---
            // 从 state 中读取 maxContext 的值并填充到输入框中，如果值不存在则使用默认值 20
            get('api-max-context').value = state.config.api.maxContext || 20; 
            // --- 新增结束 ---
            themeBgColor.value = state.config.colors.bgColor; 
            themeTextColor.value = state.config.colors.textColor; 
            themeGlassBg.value = rgbaToHex(state.config.colors.glassBg); 
            themeUserBubble.value = rgbaToHex(state.config.colors.userBubble); 
            themeUserText.value = state.config.colors.userText; 
            themeAiBubble.value = rgbaToHex(state.config.colors.aiBubble); 
            themeAiText.value = state.config.colors.aiText; 
            fontFamilySelect.value = state.config.fontFamily; 
            showView('settings'); 
        });
        backBtns.forEach(btn => btn.addEventListener('click', () => showView('home')));
        avatarContainer.addEventListener('click', () => avatarUpload.click());

        const handleAssetUpload = async (file, assetKey, elementToUpdate, isImageSrc) => {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (event) => {
                const dataUrl = event.target.result;
                setAssetValue(state, assetKey, dataUrl);
                if (isImageSrc) elementToUpdate.src = dataUrl;
                else elementToUpdate.style.backgroundImage = `url(${dataUrl})`;
                await saveState();
                showToast('资源已更新');
            };
            reader.readAsDataURL(file);
        };

        avatarUpload.addEventListener('change', e => handleAssetUpload(e.target.files[0], 'avatarImage', avatarImg, true));
        bgUploadInput.addEventListener('change', e => handleAssetUpload(e.target.files[0], 'bgImage', phoneScreen, false));
        avatarFrameUploadInput.addEventListener('change', e => handleAssetUpload(e.target.files[0], 'avatarFrameImage', avatarFrame, true));
        bgUploadBtn.addEventListener('click', () => bgUploadInput.click());
        avatarFrameUploadBtn.addEventListener('click', () => avatarFrameUploadInput.click());

        const hexToRgba = (hex, alpha) => { const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; };
        const rgbaToHex = (rgba) => { if (!rgba || !rgba.startsWith('rgba')) return '#000000'; const parts = rgba.substring(rgba.indexOf('(') + 1, rgba.lastIndexOf(')')).split(','); const r = parseInt(parts[0].trim()), g = parseInt(parts[1].trim()), b = parseInt(parts[2].trim()); return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1); };
        
        fontUpload.addEventListener('change', async e => {
            if (!e.target.files || e.target.files.length === 0) return;
            const file = e.target.files[0];
            const defaultName = file.name.replace(/\.[^/.]+$/, "");
            const fontName = await showDialog('命名新字体', '请为你的新字体命名:', { input: true, defaultValue: defaultName, placeholder: '例如: 可爱的像素字体' });
            if (!fontName || state.config.customFonts[fontName]) { showToast(fontName ? '该字体名称已存在' : '已取消上传'); return; }
            const reader = new FileReader();
            reader.onload = async (event) => {
                const dataUrl = event.target.result;
                state.config.customFonts[fontName] = dataUrl; await saveState(); renderFontOptions();
                fontFamilySelect.value = fontName; await applyFont(fontName); state.config.fontFamily = fontName;
                await saveState(); showToast(`字体 '${fontName}' 已添加并应用`);
            };
            reader.readAsDataURL(file);
        });
        
        fontFamilySelect.addEventListener('change', async e => {
            const selectedFont = e.target.value; state.config.fontFamily = selectedFont;
            await applyFont(selectedFont); await saveState();
        });

        const showFontManager = () => {
            const fontListContainer = document.createElement('div'); fontListContainer.className = 'space-y-2 max-h-60 overflow-y-auto';
            const customFonts = Object.keys(state.config.customFonts);
            if (customFonts.length === 0) { fontListContainer.innerHTML = `<p class="opacity-70 text-center">没有已导入的字体。</p>`; } 
            else {
                customFonts.forEach(fontName => {
                    const item = document.createElement('div'); item.className = 'flex items-center justify-between p-2 bg-white/10 rounded';
                    const nameSpan = document.createElement('span'); nameSpan.textContent = fontName; item.appendChild(nameSpan);
                    const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = `<i class="fas fa-trash-alt"></i>`; deleteBtn.className = 'p-2 text-red-400 hover:text-red-500';
                    deleteBtn.onclick = async () => {
                        const confirmed = await showDialog('确认删除', `确定要永久删除字体 "${fontName}" 吗？此操作无法撤销。`);
                        if (confirmed) {
                            if (state.config.fontFamily === fontName) { state.config.fontFamily = "'Inter', sans-serif"; await applyFont(state.config.fontFamily); fontFamilySelect.value = state.config.fontFamily; showToast(`当前字体 "${fontName}" 已删除，已切换回默认字体。`); } 
                            else { showToast(`字体 "${fontName}" 已删除。`); }
                            delete state.config.customFonts[fontName]; await db.delete('assets', `font-${fontName}`);
                            await saveState(); renderFontOptions(); showFontManager();
                        }
                    };
                    item.appendChild(deleteBtn); fontListContainer.appendChild(item);
                });
            }
            showDialog('管理字体', fontListContainer, { buttons: [{ text: '关闭', value: true, class: 'bg-gray-500/50' }] });
        };
        manageFontsBtn.addEventListener('click', showFontManager);

        saveSettingsBtn.addEventListener('click', async () => {
            state.config.signature = get('signature-input').value; state.config.api.baseUrl = apiBaseUrl.value; state.config.api.key = apiKey.value; state.config.api.model = apiModel.value;state.config.api.maxContext = parseInt(get('api-max-context').value) || 20;
            state.config.colors.bgColor = themeBgColor.value; state.config.colors.textColor = themeTextColor.value; state.config.colors.glassBg = hexToRgba(themeGlassBg.value, 0.15); state.config.colors.userBubble = hexToRgba(themeUserBubble.value, 0.7);
            state.config.colors.userText = themeUserText.value; state.config.colors.aiBubble = hexToRgba(themeAiBubble.value, 0.8); state.config.colors.aiText = themeAiText.value;
            applyColors(state.config.colors); signatureDisplay.textContent = state.config.signature;
            await saveState(); showToast('设置已保存');
        });

        restoreAppearanceBtn.addEventListener('click', async () => {
            const confirmed = await showDialog('还原外观', '确定要移除背景图和头像框吗？');
            if (confirmed) { state.config.bgImage = null; state.config.avatarFrameImage = null; phoneScreen.style.backgroundImage = ''; avatarFrame.src = ''; await saveState(); showToast('已还原默认外观'); }
        });

        saveRoleBtn.addEventListener('click', async () => {
            state.role.playerName = get('player-name').value; state.role.playerGender = get('player-gender').value; state.role.playerPersona = get('player-persona').value; state.role.roleName = get('role-name').value; state.role.roleGender = get('role-gender').value; state.role.rolePersona = get('role-persona').value; state.role.promptInstructions = get('prompt-instructions').value;
            await saveState(); showToast('角色设置已保存');
        });

        async function toggleFullscreen() {
            const isNowFullscreen = !state.ui.isFullscreen;
            state.ui.isFullscreen = isNowFullscreen;

            document.body.classList.toggle('fullscreen-mode', isNowFullscreen);
            
            const icon = fullscreenBtn.querySelector('i');
            const text = fullscreenBtn.querySelector('span');

            if (isNowFullscreen) {
                icon.className = 'fas fa-compress';
                text.textContent = '退出全屏';
                showToast('按 Esc 键可退出全屏');
            } else {
                icon.className = 'fas fa-expand';
                text.textContent = '全屏';
            }
            await saveState();
        }
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.body.classList.contains('fullscreen-mode')) {
                toggleFullscreen();
            }
        });

        const renderChatHistory = (options = {}) => {
            const { autoScroll = true, checkIndex = null } = options;
            const isStoryMode = state.chat.mode === 'story';

            // --- UI清理与模式切换 ---
            multifunctionMenu.classList.add('hidden');
            stickerDrawer.classList.remove('open');
            chatHistory.innerHTML = '';
            // 根据当前是否是剧情模式，添加/移除专用class
            chatPage.classList.toggle('story-mode-active', isStoryMode);
            
            if (!state.chat.history) state.chat.history = [];

            let inStorySegment = false;
            // 如果不在剧情模式，则最后一个“剧情开始”标记无效
            const lastStoryStartIndex = isStoryMode ? state.chat.history.findLastIndex(msg => msg.type === 'story_start') : -1;

            state.chat.history.forEach((msg, index) => {
                // 标记当前是否在活跃的剧情段落中
                if (lastStoryStartIndex !== -1 && index > lastStoryStartIndex) {
                    inStorySegment = true;
                } else {
                    inStorySegment = false;
                }
                
                // 1. 系统消息处理
                if ((msg.sender === 'system' && msg.type !== 'story_review_placeholder') || msg.type === 'story_start') {
                    if (msg.storyContent) {
                        chatHistory.appendChild(createStoryAnchor(msg));
                    } else {
                        chatHistory.appendChild(createSystemMessage(msg));
                    }
                    return;
                }
// --- 新增代码：处理剧情回顾占位符 (已增加长按删除) ---
                if (msg.type === 'story_review_placeholder') {
                    const placeholderWrapper = document.createElement('div');
                    placeholderWrapper.className = 'system-message-wrapper cursor-pointer';
                    
                    const textSpan = document.createElement('span');
                    textSpan.className = 'system-message-text hover:bg-white/20 transition-colors duration-200';
                    
                    const visibleContent = msg.archivedContent.filter(entry => 
                        entry.type !== 'story_start' && entry.type !== 'story_end'
                    );

                    textSpan.innerHTML = `<i class="fas fa-book-open mr-2"></i>剧情回顾 (共 ${visibleContent.length} 条内容)`;
                    
                    placeholderWrapper.appendChild(textSpan);
                    chatHistory.appendChild(placeholderWrapper);
                    
                    // --- 长按删除逻辑 ---
                    let pressTimer;
                    const startPress = () => {
                        pressTimer = setTimeout(async () => {
                            const confirmed = await showDialog('删除剧情回顾', '确定要永久删除这段已存档的剧情回顾吗？此操作无法撤销。', {
                                buttons: [{ text: '取消', value: false, class: 'bg-gray-500/50' }, { text: '删除', value: true, class: 'bg-red-500/80' }]
                            });
                            if (confirmed) {
                                const indexToDelete = state.chat.history.findIndex(m => m.id === msg.id);
                                if (indexToDelete > -1) {
                                    state.chat.history.splice(indexToDelete, 1);
                                    await saveState();
                                    renderChatHistory({ autoScroll: false });
                                    showToast('剧情回顾已删除');
                                }
                            }
                        }, 750); // 750毫秒判定为长按
                    };

                    const cancelPress = (e) => {
                        clearTimeout(pressTimer);
                    };

                    placeholderWrapper.addEventListener('mousedown', startPress);
                    placeholderWrapper.addEventListener('mouseup', cancelPress);
                    placeholderWrapper.addEventListener('mouseleave', cancelPress);
                    placeholderWrapper.addEventListener('touchstart', startPress, { passive: true });
                    placeholderWrapper.addEventListener('touchend', cancelPress);
                    
                    // --- 单击查看逻辑 ---
                    placeholderWrapper.addEventListener('click', (e) => {
                        // 如果长按计时器正在运行，说明这可能是一个长按的开始，不应触发单击
                        if (pressTimer) { 
                            clearTimeout(pressTimer);
                        }
                        
                        const storyLogContainer = document.createElement('div');
                        storyLogContainer.className = 'space-y-3 max-h-[60vh] overflow-y-auto scrollable-content p-2 -m-2';
                        storyLogContainer.style.fontFamily = 'var(--custom-font)';

                        if (visibleContent.length > 0) {
                            visibleContent.forEach(entry => {
                                const storyEntry = document.createElement('div');
                                let narrativeText = '';

                                if (entry.sender === 'user') {
                                    narrativeText = `<strong>${state.role.playerName || '你'}:</strong><br><div class="pl-2 border-l-2 border-current/20 mt-1">${(entry.text || '').replace(/\n/g, '<br>')}</div>`;
                                } else if (entry.sender === 'ai') {
                                    narrativeText = (entry.text || '').replace(/\n/g, '<br>');
                                } else if (entry.sender === 'system') {
                                    storyEntry.className = 'text-center opacity-70 text-xs py-1';
                                    narrativeText = `--- ${entry.text} ---`;
                                }
                                
                                if (narrativeText) {
                                    storyEntry.innerHTML = narrativeText;
                                    storyLogContainer.appendChild(storyEntry);
                                }
                            });
                        } else {
                            storyLogContainer.innerHTML = `<p class="text-center opacity-60">这段剧情没有内容。</p>`;
                        }

                        showDialog('剧情回顾', storyLogContainer, {
                            buttons: [{ text: '关闭', value: true, class: 'bg-gray-500/50' }]
                        });
                    });

                    return; // 处理完占位符后，跳过本次循环的剩余部分
                }
                // --- 新增代码结束 ---
                // 2. 根据是否在活跃剧情段落中，决定渲染方式
                if (inStorySegment) {
                    // --- 渲染为“叙事文本块” ---
                    const block = document.createElement('div');
                    block.className = 'story-block'; // 使用这个class来获得剧本风格
                    block.dataset.index = index;
                    block.dataset.id = msg.id;

                    const content = document.createElement('p');
                    let narrativeText = '';

                    if (msg.sender === 'user') {
                        narrativeText = `<strong>${state.role.playerName || '你'}:</strong> ${msg.text.replace(/\n/g, '<br>')}`;
                    } else { // AI sender
                        narrativeText = msg.text.replace(/\n/g, '<br>');
                    }
                    content.innerHTML = narrativeText;
                    block.appendChild(content);

                    // 为叙事块添加长按/右键事件，以便管理
                    let pressTimer;
                    block.addEventListener('mousedown', () => { pressTimer = setTimeout(() => manageChatMessage(index), 750); });
                    block.addEventListener('mouseup', () => clearTimeout(pressTimer));
                    block.addEventListener('mouseleave', () => clearTimeout(pressTimer));
                    block.addEventListener('touchstart', () => { pressTimer = setTimeout(() => manageChatMessage(index), 750); }, { passive: true });
                    block.addEventListener('touchend', () => clearTimeout(pressTimer));

                    chatHistory.appendChild(block);

                } else {
                    // --- 渲染为“手机聊天气泡” ---
                    const bubbleWrapper = document.createElement('div');
                    bubbleWrapper.className = `flex w-full ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`;
                    
                    let bubble;
                    switch (msg.type) {
                        case 'transfer': bubble = createTransferBubble(msg); break;
                        case 'voice': bubble = createVoiceBubble(msg); break;
                        case 'sticker': bubble = createStickerBubble(msg); break;
                        case 'html': bubble = createHtmlBubble(msg); break;
                        case 'image': bubble = createImageBubble(msg); break;
                        default: bubble = createTextBubble(msg);
                    }
                    bubble.dataset.index = index;
                    bubble.dataset.id = msg.id;
                    
                    // (批量删除逻辑保持不变)
                    if(isChatBatchDeleteMode) {
                        // ... (批量删除代码无需修改)
                        const container = document.createElement('div');
                        container.className = 'relative';
                        bubble.classList.add('pl-12');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'batch-delete-checkbox form-checkbox h-5 w-5 bg-white/30 rounded text-indigo-500 border-none focus:ring-0';
                        if (index === checkIndex) checkbox.checked = true;
                        container.appendChild(bubble);
                        container.appendChild(checkbox);
                        bubbleWrapper.appendChild(container);
                    } else {
                        let pressTimer;
                        bubble.addEventListener('mousedown', () => { pressTimer = setTimeout(() => manageChatMessage(index), 750); });
                        bubble.addEventListener('mouseup', () => clearTimeout(pressTimer));
                        bubble.addEventListener('mouseleave', () => clearTimeout(pressTimer));
                        bubble.addEventListener('touchstart', () => { pressTimer = setTimeout(() => manageChatMessage(index), 750); }, { passive: true });
                        bubble.addEventListener('touchend', () => clearTimeout(pressTimer));
                        bubbleWrapper.appendChild(bubble);
                    }
                    chatHistory.appendChild(bubbleWrapper);
                }
            });
            
            // --- UI状态更新 ---
            storyModeBtn.classList.toggle('text-blue-400', isStoryMode);
            [transferBtn, voiceModeBtn, stickerPanelBtn].forEach(btn => btn.disabled = isStoryMode);
            
            if (isStoryMode) {
                aiReplyBtn.textContent = '继续剧情';
                userInput.placeholder = '输入你的行动或对话';
            } else {
                aiReplyBtn.textContent = '角色回复';
                userInput.placeholder = state.chat.sendMode === 'voice' ? '输入语音文字...' : '请输入消息...';
            }

            // (批量删除UI和滚动逻辑保持不变)
            chatFooter.style.display = isChatBatchDeleteMode ? 'none' : 'flex';
            chatBatchActions.style.display = isChatBatchDeleteMode ? 'flex' : 'none';
            
            
            if (checkIndex !== null) {
                const targetEl = chatHistory.querySelector(`[data-index="${checkIndex}"]`);
                if (targetEl) targetEl.scrollIntoView({ behavior: 'auto', block: 'center' });
            } else if (autoScroll && !isChatBatchDeleteMode) { 
                chatHistory.scrollTop = chatHistory.scrollHeight; 
            }

            affinityDisplay.textContent = `好感度：${state.chat.affinity}/100`;
        };
        
        const createStoryAnchor = (msg) => {
            const wrapper = document.createElement('div');
            // 添加一个特殊的类名和 data-id 以便点击时识别
            wrapper.className = 'system-message-wrapper story-block-anchor cursor-pointer hover:bg-white/20 transition-colors duration-200';
            wrapper.dataset.storyBlockId = msg.id;

            const content = msg.storyContent.length > 0
                ? `--- 剧情回顾 (共 ${msg.storyContent.length} 条内容) ---`
                : '--- 进入剧情模式 ---';
            
            wrapper.innerHTML = `<span class="system-message-text"><i class="fas fa-book-open mr-2"></i>${content}</span>`;
            return wrapper;
        };

        chatHistory.addEventListener('click', async (e) => {
            // --- 新增：处理剧情锚点点击 ---
            const storyAnchor = e.target.closest('.story-block-anchor');
            if (storyAnchor) {
                const blockId = parseInt(storyAnchor.dataset.storyBlockId, 10);
                const storyBlock = state.chat.history.find(m => m.id === blockId);

                if (storyBlock && storyBlock.storyContent) {
                    // 创建一个容器来展示剧情日志
                    const storyLogContainer = document.createElement('div');
                    storyLogContainer.className = 'space-y-4 max-h-[60vh] overflow-y-auto scrollable-content p-2 -m-2';
                    storyLogContainer.style.fontFamily = 'var(--custom-font)'; // 继承字体

                    storyBlock.storyContent.forEach(entry => {
                        const storyEntry = document.createElement('div');
                        let narrativeText = '';

                        if (entry.sender === 'user') {
                            // 核心：处理用户输入换行
                            narrativeText = `<strong>${state.role.playerName || '你'}:</strong><br>${entry.text.replace(/\n/g, '<br>')}`;
                        } else { // AI sender
                            // 核心：处理AI回复换行
                            narrativeText = entry.text.replace(/\n/g, '<br>');
                        }
                        
                        storyEntry.innerHTML = narrativeText;
                        storyLogContainer.appendChild(storyEntry);
                    });
                    
                    if(storyBlock.storyContent.length === 0){
                        storyLogContainer.innerHTML = `<p class="text-center opacity-60">暂无剧情内容</p>`;
                    }

                    showDialog('剧情回顾', storyLogContainer, {
                        buttons: [{ text: '关闭', value: true, class: 'bg-gray-500/50' }]
                    });
                }
                return; // 阻止事件冒泡到下面的旧逻辑
            }

            // --- 原有的事件处理逻辑 ---
            const msgContainer = e.target.closest('.message-bubble'); // 不再检查 .story-block
            if (!msgContainer) return;

            const msgId = parseInt(msgContainer.dataset.id, 10);
            const msg = state.chat.history.find(m => m.id === msgId);
            if (!msg) return;

            // --- 语音消息点击处理 ---
            if (e.target.closest('.voice-bubble') && msg.type === 'voice') {
                msg.isExpanded = !msg.isExpanded;
                
                const scrollPosition = chatHistory.scrollHeight - chatHistory.scrollTop;
                renderChatHistory({ autoScroll: false });
                chatHistory.scrollTop = chatHistory.scrollHeight - scrollPosition;
                
                await saveState();
                return;
            }

            // --- 转账消息点击处理 (增加退回功能) ---
            if (e.target.closest('.transfer-bubble.pending') && msg.type === 'transfer' && msg.sender === 'ai') {
                const action = await showDialog(
                    '处理转账',
                    `你收到一笔来自 ${state.role.roleName || '对方'} 的转账，金额 ${msg.amount.toFixed(2)} 元。`,
                    {
                        buttons: [
                            { text: '取消', value: false, class: 'bg-gray-500/50' },
                            { text: '退回', value: 'return', class: 'bg-yellow-600/80' },
                            { text: '收取', value: 'receive', class: 'bg-blue-500' }
                        ]
                    }
                );

                if (action === 'receive') {
                    msg.status = 'received';
                    state.sui.balance += msg.amount;
                    state.sui.transactions.unshift({
                        id: Date.now(),
                        timestamp: new Date().toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }),
                        description: `收到来自 ${state.role.roleName || '对方'} 的转账`,
                        amount: msg.amount,
                        relatedChatId: msg.id
                    });
                    showToast(`收款成功，余额增加 ${msg.amount.toFixed(2)}`);
                    await saveState();
                    renderChatHistory({ autoScroll: false });
                } else if (action === 'return') {
                    msg.status = 'returned';
                    state.sui.balance += msg.amount; // 修正：退回给自己，余额应该增加
                    state.sui.transactions.unshift({
                        id: Date.now(),
                        timestamp: new Date().toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }),
                        description: `${state.role.playerName || '你'} 退回了一笔转账`,
                        amount: msg.amount,
                        relatedChatId: msg.id
                    });
                    showToast(`已退回该笔转账，资金已返还`);
                    await saveState();
                    renderChatHistory({ autoScroll: false });
                }
                return;
            }
        });
        const createSystemMessage = (msg) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'system-message-wrapper';
            wrapper.innerHTML = `<span class="system-message-text">${msg.text}</span>`;
            return wrapper;
        };

        const createTextBubble = (msg) => {
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${msg.sender}`;
            bubble.textContent = msg.text;
            return bubble;
        };

        const createTransferBubble = (msg) => {
            const bubble = document.createElement('div');
            const statusText = { pending: '待查收', received: '已收款', returned: '已退回' };
            // --- 核心修正 ---
            // 在这里添加了 'message-bubble' 类
            bubble.className = `message-bubble transfer-bubble ${msg.sender} ${msg.status}`;
            bubble.innerHTML = `
                <div class="transfer-content">
                    <i class="fas fa-money-bill-transfer"></i>
                    <div class="transfer-info">
                        <h4>转账</h4>
                        <p>${msg.message || '转账给你'}</p>
                    </div>
                </div>
                <div class="transfer-footer">${statusText[msg.status]}</div>
            `;
            return bubble;
        };

        const createVoiceBubble = (msg) => {
            const bubble = document.createElement('div');
            bubble.className = `message-bubble voice-bubble ${msg.sender}`;
            bubble.innerHTML = `
                <i class="fas fa-play-circle"></i>
                <span class="voice-duration">${msg.duration}"</span>
                ${msg.isExpanded ? `<div class="voice-transcript">${msg.text}</div>` : ''}
            `;
            return bubble;
        };

        const createStickerBubble = (msg) => {
            const bubble = document.createElement('div');
            // --- 核心修正 ---
            // 在这里添加了 'message-bubble' 类
            bubble.className = `message-bubble sticker-bubble ${msg.sender}`;
            const sticker = state.stickers.find(s => s.id === msg.stickerId);
            if (sticker) {
                bubble.innerHTML = `<img src="${sticker.imageDataUrl}" alt="${sticker.meaning}">`;
            } else {
                bubble.innerHTML = `[表情已失效]`;
            }
            return bubble;
        };
        
        const createHtmlBubble = (msg) => {
        const bubble = document.createElement('div');
        // 核心修正：添加了 'html-bubble' 类，以应用正确的透明容器样式
        bubble.className = `message-bubble html-bubble ${msg.sender}`; 
        
        // 安全提示：直接使用 innerHTML 可能会有XSS风险。
        // 在此应用中，我们信任AI生成的内容，因此直接使用以实现功能。
        bubble.innerHTML = msg.htmlContent;
        
        return bubble;
    };
        const createImageBubble = (msg) => {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble image-bubble ${msg.sender}`;
        bubble.innerHTML = `<img src="${msg.imageUrl}" alt="用户发送的图片">`;
        bubble.querySelector('img').addEventListener('click', () => {
            window.open(msg.imageUrl, '_blank');
        });
        return bubble;
    };
    
        const manageChatMessage = (index) => {
            const msg = state.chat.history[index];
            if (!msg) return; // 只检查消息是否存在

            // 优先处理系统消息（如模式切换分割线）
            if (msg.sender === 'system') {
                showDialog('管理系统消息', `消息内容: "${msg.text}"`, {
                    buttons: [
                        { text: '取消', value: 'cancel', class: 'bg-gray-500/50' },
                        { text: '删除', value: 'delete', class: 'bg-red-500/80' }
                    ]
                }).then(async action => {
                    if (action === 'delete') {
                        state.chat.history.splice(index, 1);
                        await saveState();
                        renderChatHistory({ autoScroll: false });
                        showToast('消息已删除');
                    }
                });
                return; // 处理完毕，退出函数
            }

            // --- 以下为原有的对用户和AI消息的处理逻辑 ---
            let dialogMessage = '';
            let dialogButtons = [];
            
            switch (msg.type) {
                case 'text': dialogMessage = `"${(msg.text || '').substring(0, 50)}..."`; break;
                case 'voice': dialogMessage = `一条 ${msg.duration}" 的语音消息`; break;
                case 'transfer': dialogMessage = `一笔 ${msg.amount} 元的转账`; break;
                case 'sticker': dialogMessage = `一个含义为 "${msg.meaning}" 的表情`; break;
                case 'html': dialogMessage = `一个HTML模块 (内容: "${msg.htmlContent.substring(0, 50)}...")`; break;
                default: dialogMessage = `"${(msg.text || '').substring(0, 50)}..."`;
            }
            
            const commonButtons = [
                {text: '取消', value: 'cancel', class: 'bg-gray-500/50'},
                {text: '批量删除', value: 'batch-delete', class: 'bg-yellow-600/80'},
                {text: '删除', value: 'delete', class: 'bg-red-500/80'}
            ];

            if ((msg.type === 'text' || state.chat.mode === 'story') && !isChatBatchDeleteMode) {
                dialogButtons = [...commonButtons, {text: '编辑', value: 'edit', class: 'bg-blue-500'}];
            } else {
                dialogButtons = commonButtons;
            }

            showDialog('管理消息', dialogMessage, { 
                buttons: dialogButtons.map(b => b.disabled ? {...b, class: `${b.class} opacity-50 cursor-not-allowed`} : b) 
            }).then(async action => {
                const buttonInfo = dialogButtons.find(b => b.value === action);
                if (buttonInfo && buttonInfo.disabled) return;

                if (action === 'edit') {
                    const newText = await showDialog('编辑消息', '', { input: true, defaultValue: msg.text });
                    if (newText) {
                        state.chat.history[index].text = newText;
                        await saveState();
                        renderChatHistory({ autoScroll: false });
                        showToast('消息已更新');
                    }
                } else if (action === 'delete') {
                    const confirmed = await showDialog('确认删除', '确定要删除这条消息吗？');
                    if (confirmed) {
                        state.chat.history.splice(index, 1);
                        await saveState();
                        renderChatHistory({ autoScroll: false });
                        showToast('消息已删除');
                    }
                } else if (action === 'batch-delete') {
    multifunctionMenu.classList.add('hidden');
    stickerDrawer.classList.remove('open'); // 保持状态干净
    stickerDrawer.classList.add('hidden');    // <--- 核心更改：强制隐藏，避免布局冲突
    isChatBatchDeleteMode = true;
    renderChatHistory({ checkIndex: index });
                }
            });
        };

        

        const sendMessage = async (messageObject) => {
            // 基础校验
            if (!messageObject.text && messageObject.sender !== 'system' && messageObject.type !== 'sticker' && messageObject.type !== 'transfer') return;
            if (messageObject.sender !== 'system' && (!messageObject.text || !messageObject.text.trim()) && (messageObject.type === 'text' || messageObject.type === 'voice')) return;
            
            // 不论何种模式，都直接将消息推入主历史记录
            state.chat.history.push(messageObject);
            
            if (messageObject.sender === 'user') {
                userInput.value = '';
                // 发送后重置输入框高度
                setTimeout(() => {
                    userInput.style.height = 'auto';
                }, 0);
            }
            
            await saveState();
            // 渲染由 renderChatHistory 根据当前模式决定
            renderChatHistory({ autoScroll: true });
        };

        const handleSend = () => {
            if (UILock.isLocked()) return;
            const text = userInput.value;
            if (!text.trim()) return;

            let msgObject;
            const isStoryMode = state.chat.mode === 'story';

            if (isStoryMode) {
                msgObject = { id: Date.now(), sender: 'user', type: 'text', text: text };
            } else if (state.chat.sendMode === 'voice') {
                msgObject = {
                    id: Date.now(), sender: 'user', type: 'voice',
                    text: text, duration: Math.max(1, Math.ceil(text.length / 3)), isExpanded: false
                };
            } else {
                msgObject = { id: Date.now(), sender: 'user', type: 'text', text: text };
            }
            sendMessage(msgObject);
        };
        
        const adjustTextareaHeight = () => {
            userInput.style.height = 'auto'; // Reset height
            const newHeight = Math.min(userInput.scrollHeight, 120); // 120px is max-height
            userInput.style.height = `${newHeight}px`;
        };

        userInput.addEventListener('input', adjustTextareaHeight);

        userInput.addEventListener('keydown', (e) => { 
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                handleSend(); 
                // Reset height after sending
                setTimeout(() => {
                    userInput.style.height = 'auto';
                }, 0);
            }
        });
        userInput.addEventListener('focus', () => { setTimeout(() => { chatFooter.scrollIntoView({ behavior: 'smooth', block: 'end' }); }, 300); });
        
        const createPhoneApiPrompt = () => {
    const now = new Date();
    const currentTimeString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

    // --- I am upgrading the system prompt to include instructions for image recognition ---
    let systemPrompt = `
# 当前时间
- **${currentTimeString}**
- 你必须意识到这是当前的现实时间。你的回复（例如问候语）应当与这个时间点相符。例如，如果是深夜，你应该说“这么晚了还没睡？”而不是“下午好”。

# 你的状态
- **账户余额**: ${state.sui.balance.toFixed(2)} 元

# MODE: PHONE CHAT (手机聊天模式)
# ===================================

# 你的核心任务
- **身份**: 你是 **${state.role.roleName || '角色'}** (${state.role.roleGender || '未设定'})。
- **人设**: ${state.role.rolePersona || '未设定'}
- **场景**: 你正在一个手机聊天APP里，与 **${state.role.playerName || '玩家'}** 进行一对一的聊天。

# 绝对禁止事项 (DO NOT DO THIS)
- **绝对禁止描写**: 严禁输出任何描述你动作、神态、心理活动或环境的文字。例如：*我笑了*、(看着屏幕)、[他感到一阵温暖]、窗外的雨停了。
- **绝对禁止小说风格**: 严禁使用第三人称叙事或任何类似小说的文体。

# 可用功能
- **视觉识别**: 你现在可以“看到”用户发送的图片。当收到图片时，你应该描述图片内容并作出符合你角色的、有情感的、自然的反应。
- **转账**: \`[SEND_TRANSFER:{"amount":金额,"message":"留言"}]\`
- **处理转账**: 收到玩家转账后，必须在回复中包含 \`[TRANSFER_ACTION:receive,ID:消息ID]\` 或 \`[TRANSFER_ACTION:return,ID:消息ID]\`。
- **发语音**: \`[VOICE_MESSAGE]语音内容[/VOICE_MESSAGE]\`
- **发表情**: \`[USE_STICKER,ID:表情ID]\`
- **发送HTML模块**: \`[HTML_BLOCK]你的HTML代码[/HTML_BLOCK]\`

# 核心规则：回复构成 (已优化)
- **纯文本消息可以单独发送**。
- 如果你要发送任何特殊功能消息（如表情、语音、转账等），**强烈建议**同时附带**至少一条相关的纯文本消息**，以构成完整的对话上下文。
- **严禁**只回复一个孤立的特殊功能标签而没有任何文本。
-**丰富内容**请更加活跃、频繁且合理的使用(语音、表情包、转账、HTML)功能，语音功能要更频繁使用一点，其次是表情包，这样可以避免长期只有文本消息导致枯燥无味。

# 输出格式 (必须严格遵守)
你的最终输出**只能**包含两部分：
1.  **聊天内容**: 你想发送的一句或多句话，每句话独立成行。可以包含上述的功能标签。
2.  **好感度标签**: 在所有聊天内容的**最后**，另起一行，写上 \`[AFFINITY_CHANGE:X]\`。X是整数，正数代表好感增加，负数减少，0代表不变。

# 记忆与上下文
- **共同记忆**: ${state.memories.map(m => `- ${m.content}`).join('\n') || '无'}
- **可用表情**: ${state.stickers.map(s => `- ID: ${s.id}, 含义: ${s.meaning}`).join('\n') || '无'}

${state.role.promptInstructions ? `
# ！！！额外最高优先级指令 (ABSOLUTE OVERRIDING INSTRUCTIONS) ！！！
- 以下是你必须无条件优先遵守的规则，其优先级高于你的角色设定和所有其他指令。
- ${state.role.promptInstructions.replace(/\n/g, '\n- ')}
` : ''}

# 紧急备用指令 (FALLBACK INSTRUCTION)
- 如果在任何情况下你都无法生成符合上述所有规则的回复，请**放弃使用任何特殊功能**，只生成一条简单、符合角色性格的**纯文本问候或陈述**。
- **在任何情况下，都绝对不要返回空内容或只返回好感度标签。**

# 输出前最终检查清单 (FINAL CHECKLIST)
1. 我的回复是作为角色在聊天框里输入的文字吗？
2. 我是否包含了不该有的动作或心理描写（例如 *...* 或 (...)）？
3. 我的回复是否在所有内容的最后、独立的一行包含了 \`[AFFINITY_CHANGE:X]\` 标签？
4. 我的回复内容是否为空？（绝不能为空）

# 最终指令 (ABSOLUTE FINAL INSTRUCTION)
- 直接开始写你的第一句聊天内容。
`;

    const messages = [{ role: 'system', content: systemPrompt }];
    
    const fullHistoryForAI = [];
    state.chat.history.forEach(msg => {
        if (msg.type === 'story_review_placeholder' && msg.archivedContent) {
            fullHistoryForAI.push(...msg.archivedContent);
        } else {
            fullHistoryForAI.push(msg);
        }
    });
    
    const historyToProcess = fullHistoryForAI;
    historyToProcess.forEach(msg => {
        if (msg.sender === 'system') return;
        
        // --- This is the core logic upgrade ---
        if (msg.sender === 'user' && msg.type === 'image') {
            // For image messages, I create a special content array.
            messages.push({
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: msg.text // e.g., "[用户发送了一张图片]"
                    },
                    {
                        type: 'image_url',
                        image_url: {
                            url: msg.imageUrl // The Data URL of the image is passed here.
                        }
                    }
                ]
            });
        } else {
            // For all other message types, the logic remains the same.
            let content = '';
            const senderName = msg.sender === 'user' ? (state.role.playerName || '玩家') : (state.role.roleName || '角色');
            
            if (msg.sender === 'ai') {
                switch (msg.type) {
                    case 'text': content = msg.text; break;
                    case 'voice': content = `[VOICE_MESSAGE]${msg.text}[/VOICE_MESSAGE]`; break;
                    case 'sticker': content = `[USE_STICKER,ID:${msg.stickerId}]`; break;
                    case 'html': content = `[HTML_BLOCK]${msg.htmlContent}[/HTML_BLOCK]`; break;
                    case 'transfer':
                        const transferPayload = { amount: msg.amount, message: msg.message };
                        content = `[SEND_TRANSFER:${JSON.stringify(transferPayload)}]`;
                        break;
                    default: content = msg.text || '';
                }
            } else { // user
                switch (msg.type) {
                    case 'text': content = msg.text; break;
                    case 'voice': content = `[${senderName}发送了一条语音消息]: ${msg.text}`; break;
                    case 'sticker': content = `[${senderName}发送了一个表情，含义是: ${msg.meaning}]`; break;
                    case 'html': content = `[${senderName}发送了一个自定义模块]`; break;
                    case 'transfer': content = `[${senderName}向你转账 ${msg.amount}元，留言: "${msg.message}", ID: ${msg.id}]`; break;
                    default: content = msg.text || '';
                }
            }
            if (content) {
                messages.push({ role: msg.sender === 'user' ? 'user' : 'assistant', content: content });
            }
        }
    });

    return messages;
};
        const createStoryApiPrompt = () => {
            const now = new Date();
            const currentTimeString = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

            let systemPrompt = `
# 当前时间
- **${currentTimeString}**
- 你在叙述故事时，必须让故事的氛围和角色的行为与这个现实时间点保持一致。例如，如果是深夜，环境描写应该是夜晚的景象，角色的对话也应符合深夜的语境。

# 你的状态
- **账户余额**: ${state.sui.balance.toFixed(2)} 元

# MODE: NARRATIVE STORY (剧情模式)
# ===================================

# 你的核心任务
- **身份**: 你是**故事的叙述者**，同时扮演着角色 **${state.role.roleName || '角色'}** (${state.role.roleGender || '未设定'})。
- **人设**: ${state.role.rolePersona || '未设定'})。
- **场景**: 你和玩家 **${state.role.playerName || '玩家'}** 在同一个真实世界场景中进行实时互动。
- **输出**: 你的所有回复**必须**是**小说风格的、富有描写的段落**。

# 绝对核心要求 (MUST DO THIS)
- **必须进行详细描写**: 你的回复必须包含对环境、角色的动作、表情、神态、以及角色内心感受的生动描写。
- **必须是小说风格**: 把自己当作一个小说家，将玩家的行动和你的回应编织成一个连贯的、有画面感的故事片段。
- **对话必须在引号内**: 角色说的话必须用引号（“ ”）包裹起来。例如：他微笑着说：“你好。”

# 绝对禁止事项 (DO NOT DO THIS)
- **绝对禁止聊天风格**: 严禁回复简短的、口语化的、像聊天软件里的消息。
- **绝对禁止剧本格式**: 严禁使用“角色名: 对话”这样的格式。

# 输出格式 (必须严格遵守)
你的最终输出**只能**包含两部分：
1.  **故事段落**: 一个完整的、连贯的、充满描写的叙事段落。
2.  **好感度标签**: 在故事段落的**最后**，另起一行，写上 \`[AFFINITY_CHANGE:X]\`。X是整数，正数代表好感增加，负数减少，0代表不变。

# 记忆与上下文
- **共同记忆**: ${state.memories.map(m => `- ${m.content}`).join('\n') || '无'}

${state.role.promptInstructions ? `
# ！！！最高优先级指令 (ABSOLUTE OVERRIDING INSTRUCTIONS) ！！！
- 以下是你必须无条件优先遵守的规则，其优先级高于你的角色设定和所有其他指令。
- ${state.role.promptInstructions.replace(/\n/g, '\n- ')}
` : ''}

// ---【新增的强化指令：为AI提供安全出口】---
# 紧急备用指令 (FALLBACK INSTRUCTION)
- 如果在任何情况下你都无法生成符合上述所有规则的复杂剧情段落，请**放弃复杂的描写**，只生成一句简单的、符合第三人称叙事风格的、关于角色 **${state.role.roleName}** 状态或动作的陈述。
- **在任何情况下，都绝对不要返回空内容。**

# 输出前最终检查清单 (FINAL CHECKLIST)
1. 我的描述是围绕角色 **${state.role.roleName}** 的第三人称叙事吗？
2. 我的回复是否在所有内容的最后、独立的一行包含了 \`[AFFINITY_CHANGE:X]\` 标签？
3. 我的回复内容是否为空？（绝不能为空）
// ---【新增指令结束】---

# 最终指令 (ABSOLUTE FINAL INSTRUCTION)
- **检查你的输出！** 你的回复必须是**小说一样的叙事段落**。
- 直接开始写你的故事段落。
`;
            const apiMessages = [{ role: 'system', content: systemPrompt }];

            // --- 你的核心逻辑保持不变 ---

            const fullHistoryForAI = [];
            state.chat.history.forEach(msg => {
                if (msg.type === 'story_review_placeholder' && msg.archivedContent) {
                    fullHistoryForAI.push(...msg.archivedContent);
                } else {
                    fullHistoryForAI.push(msg);
                }
            });

            const historyForContext = fullHistoryForAI;

            historyForContext.forEach(msg => {
                if (msg.sender === 'user' || msg.sender === 'ai') {
                    if (msg.text) {
                        const role = msg.sender === 'user' ? 'user' : 'assistant';
                        apiMessages.push({ role, content: msg.text });
                    }
                }
            });
            // --- 你的逻辑结束 ---

            return apiMessages;
        };

        async function initializeSuiBalance() {
            if (state.sui.isInitialized) return;
            const persona = state.role.rolePersona.toLowerCase();
            let balance = 0;
            if (/ceo|总裁|富豪|精英|董事长|投资人/.test(persona)) {
                balance = 5000000 + Math.random() * 100000000;
            } else if (/学生|实习生|打工人|普通|贫穷|穷/.test(persona)) {
                balance = 1000 + Math.random() * 5000;
            } else {
                balance = 50000 + Math.random() * 200000;
            }
            state.sui.balance = balance;
            state.sui.isInitialized = true;
            showToast(`【SUI：账户已激活，初始资金 ${balance.toFixed(2)}】`);
            await saveState();
        }

        async function callSuiApi(systemPrompt) {
            if (!state.config.api.baseUrl || !state.config.api.key) return null;
            console.log('%c[SUI] 正在调用SUI API...', 'color: #03a9f4; font-weight: bold;', { prompt: systemPrompt });
            try {
                const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: '请根据系统指令，立即生成所需的JSON对象。' }
];
                const response = await fetch(`${state.config.api.baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${state.config.api.key}` },
                    body: JSON.stringify({ model: state.config.api.model || 'gpt-3.5-turbo', messages: messages, temperature: 0.6 })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`%c[SUI] API 请求失败，状态码: ${response.status}.`, 'color: #f44336; font-weight: bold;', '响应:', errorText);
                    return null;
                }
                const data = await response.json();
                const content = data.choices?.[0]?.message?.content;
                if (!content) { console.warn('%c[SUI] API 响应中不包含任何内容。', 'color: #ffc107;'); return null; }
                console.log('%c[SUI] 从API收到原始文本:', 'color: #4caf50;', content);
                const jsonRegex = /({[\s\S]*})|(\[[\s\S]*\])/;
                const match = content.match(jsonRegex);
                if (!match) { console.error('%c[SUI] 解析失败：在响应中未找到有效的JSON结构。', 'color: #f44336; font-weight: bold;'); return null; }
                const jsonString = match[0];
                console.log('%c[SUI] 正则表达式提取出的JSON字符串:', 'color: #ff9800;', jsonString);
                try {
                    const parsedJson = JSON.parse(jsonString);
                    console.log('%c[SUI] JSON解析成功！', 'color: #8bc34a; font-weight: bold;', parsedJson);
                    return parsedJson;
                } catch (e) {
                    console.error('%c[SUI] JSON解析失败，即使已经提取出字符串。', 'color: #f44336; font-weight: bold;', e, '问题字符串:', jsonString);
                    return null;
                }
            } catch (error) {
                console.error("%c[SUI] callSuiApi 函数发生严重错误:", 'color: #f44336; font-weight: bold;', error);
                return null;
            }
        }

        async function generateTransactionBatch() {
            const recentHistory = state.chat.history.slice(-20).map(msg => `${msg.sender === 'user' ? (state.role.playerName || '玩家') : (state.role.roleName || '角色')}: ${msg.type === 'text' ? msg.text : `[${msg.type}消息]`}`).join('\n');
            const persona = state.role.rolePersona;
            const count = Math.floor(Math.random() * 3) + 1; // 随机生成 1-3 条

            const systemPrompt = `你是一个生活模拟器。基于以下角色设定和最近的对话，生成 ${count} 笔符合该角色生活方式的交易记录。

角色设定: ${persona}
最近对话:
${recentHistory}
---
你的输出必须是一个JSON数组，每个对象包含 "description" (字符串) 和 "amount" (数字)。
- \`amount\` 为正数代表收入，为负数代表支出。
- 请根据角色设定，合理地混合收入和支出。例如，一个CEO可能会有大额投资回报（收入）和奢侈品消费（支出）；一个学生可能会有兼职收入和生活开销。
- 描述要简洁明了。

例如，如果需要生成2笔记录:
[{"description": "季度项目奖金", "amount": +50000}, {"description": "购买新款笔记本电脑", "amount": -15800}]

不要输出任何其他内容，只输出JSON数组。`;

            const result = await callSuiApi(systemPrompt);
            
            if (result && Array.isArray(result) && result.length > 0) { // 确保结果有效且不为空
                let totalAmount = 0;
                let addedCount = 0; // 计数器，记录成功添加的交易数量
                for (const transaction of result) {
                    if (typeof transaction.description === 'string' && typeof transaction.amount === 'number') {
                        const newTransaction = {
                            id: Date.now() + Math.random(), // Add random to avoid collision in batch
                            timestamp: new Date().toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }),
                            description: transaction.description,
                            amount: transaction.amount
                        };
                        state.sui.transactions.unshift(newTransaction);
                        totalAmount += transaction.amount;
                        addedCount++; // 每成功添加一笔，计数器加一
                    }
                }
                state.sui.balance += totalAmount;

                // 核心修改：在循环外显示一条总结性通知
                if (addedCount > 0) {
                    showToast(`【SUI：已生成 ${addedCount} 笔新交易】`);
                }

                await saveState();
            }
        }

        async function generateOtherChat() {
            const recentHistory = state.chat.history.slice(-10).map(msg => `${msg.sender === 'user' ? (state.role.playerName || '玩家') : (state.role.roleName || '角色')}: ${msg.text}`).join('\n');
            const persona = state.role.rolePersona;
            const systemPrompt = `你是一个生活模拟器。基于以下角色设定，虚构一段该角色与另一人（非玩家）的简短对话（2-4句）。
角色设定: ${persona}
---
你的输出必须是一个JSON对象，格式如下: {"with": "对话者名称/身份", "log": [{"sender": "角色名", "text": "对话内容"}, {"sender": "对话者", "text": "对话内容"}]}
例如: {"with": "助理小陈", "log": [{"sender": "${state.role.roleName}", "text": "下午的会议资料准备好了吗？"}, {"sender": "助理小陈", "text": "准备好了，董事长。"}]}
不要输出任何其他内容。`;
            const result = await callSuiApi(systemPrompt);
            if (result && result.with && Array.isArray(result.log)) {
                const newChat = {
                    id: Date.now(),
                    timestamp: new Date().toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }),
                    with: result.with,
                    log: result.log
                };
                state.sui.otherChats.unshift(newChat);
                // 核心修改：使用通用的类别通知
                showToast('【SUI：新通讯记录已生成】');
                await saveState();
            }
        }

        async function generateBrowsingHistory() {
            const recentHistory = state.chat.history.slice(-10).map(msg => `${msg.sender === 'user' ? '玩家' : '角色'}: ${msg.text}`).join('\n');
            const persona = state.role.rolePersona;
            const systemPrompt = `你是一个生活模拟器。基于以下角色设定和最近对话，虚构一个该角色刚刚进行的网络浏览会话（2-3个相关页面）。
角色设定: ${persona}
最近对话:
${recentHistory}
---
你的输出必须是一个JSON对象，格式如下: {"session": [{"title": "页面标题1", "url": "https://example.com/page1"}, {"title": "页面标题2", "url": "https://example.com/page2"}]}
URL可以是虚构的但要看起来合理。标题应反映角色的兴趣或最近关心的话题。不要输出任何其他内容。`;
            const result = await callSuiApi(systemPrompt);
            if (result && Array.isArray(result.session) && result.session.length > 0) {
                const newHistory = {
                    id: Date.now(),
                    timestamp: new Date().toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }),
                    session: result.session
                };
                state.sui.browsingHistory.unshift(newHistory);
                // 核心修改：使用通用的类别通知
                showToast('【SUI：新浏览记录已生成】');
                await saveState();
            }
        }

        async function triggerSuiGeneration() {
            // 定义一个空数组，用来存放所有需要执行的生成任务（Promise）
            const promises = [];

            // --- 核心升级：调用批量交易生成函数 ---
            // 交易记录：80% 的生成概率
            if (Math.random() < 0.80) {
                promises.push(generateTransactionBatch());
            }

            // 2. 外部通讯：50% 的生成概率
            if (Math.random() < 0.50) {
                promises.push(generateOtherChat());
            }

            // 3. 浏览记录：50% 的生成概率
            if (Math.random() < 0.50) {
                promises.push(generateBrowsingHistory());
            }

            // 如果有任何任务被选中，就并行执行它们
            if (promises.length > 0) {
                try {
                    // Promise.all 会同时开始所有任务，并等待它们全部完成
                    await Promise.all(promises);
                    console.log(`%c[SUI] 成功并行生成了 ${promises.length} 组记录。`, 'color: #4caf50; font-weight: bold;');
                } catch (error) {
                    // 如果其中任何一个任务失败，这里会捕获到错误
                    console.error("%c[SUI] 并行生成记录时发生错误:", 'color: #f44336; font-weight: bold;', error);
                }
            }
        }
        
        async function getAiReply() {
            if (!state.config.api.key) {
                showDialog('API错误', '请在设置中配置API参数！');
                return;
            }
            aiReplyBtn.disabled = true;
            showToast('对方正在输入...');
            await initializeSuiBalance();

            try {
                // 此处调用指令生成函数的逻辑保持不变
                const messages = state.chat.mode === 'phone' ? createPhoneApiPrompt() : createStoryApiPrompt();
                
                const response = await fetch(`${state.config.api.baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${state.config.api.key}` },
                    body: JSON.stringify({ model: state.config.api.model || 'gpt-3.5-turbo', messages: messages, temperature: 0.7 })
                });

                if (!response.ok) throw new Error(`API request failed with status ${response.status}: ${await response.text()}`);
                
                const data = await response.json();
                let rawContent = data.choices?.[0]?.message?.content;
                
                if (!rawContent || !rawContent.trim()) {
                    console.warn("API响应为空或格式不正确:", data);
                    throw new Error("API响应为空或格式不正确。");
                }
                
                rawContent = rawContent.trim();
                
                const affinityRegex = /\[A-?F-?F-?I-?N-?I-?T-?Y-?_CHANGE:(-?\d+)\]/gi;
                const affinityMatch = [...rawContent.matchAll(affinityRegex)];
                affinityMatch.forEach(match => {
                    const affinityChange = parseInt(match[1], 10);
                    if (!isNaN(affinityChange)) {
                        state.chat.affinity = Math.max(0, Math.min(100, state.chat.affinity + affinityChange));
                        showToast(`好感度 ${affinityChange > 0 ? '+' : ''}${affinityChange}`);
                    }
                });
                
                let contentForParsing = rawContent.replace(affinityRegex, '').trim();

                if (!contentForParsing) {
                    await saveState(); 
                    return;
                }

                const messagesToSend = [];

                if (state.chat.mode === 'story') {
                    messagesToSend.push({ id: Date.now(), sender: 'ai', type: 'text', text: contentForParsing });
                } else {
                    // --- 手机模式解析逻辑已恢复 ---
                    while (contentForParsing.length > 0) {
                        let tagStartIndex = contentForParsing.indexOf('[');
                        
                        if (tagStartIndex === 0) {
                            let tagEndIndex = -1;
                            let tagNameMatch = contentForParsing.match(/^\[([A-Z_-]+)/i);
                            let tagName = tagNameMatch ? tagNameMatch[1].toUpperCase().replace(/-/g, '_') : null;

                            if (tagName === 'VOICE_MESSAGE' || tagName === 'HTML_BLOCK') {
                                const baseName = tagName.split('_').map(part => part.split('').join('[-_]?')).join('[-_]');
                                const closingRegex = new RegExp(`\\[\\/` + baseName + `\\]`, 'i');
                                const closingMatch = contentForParsing.match(closingRegex);
                                if (closingMatch) {
                                   tagEndIndex = closingMatch.index + closingMatch[0].length - 1;
                                }
                            } else if (tagName) {
                                tagEndIndex = contentForParsing.indexOf(']');
                            }

                            if (tagEndIndex === -1) {
                                messagesToSend.push({ id: Date.now() + Math.random(), sender: 'ai', type: 'text', text: contentForParsing });
                                contentForParsing = '';
                                continue;
                            }

                            const tag = contentForParsing.substring(0, tagEndIndex + 1);
                            const msgObject = parseTagToMessage(tag);
                            if (msgObject) messagesToSend.push(msgObject);
                            
                            contentForParsing = contentForParsing.substring(tagEndIndex + 1).trim();

                        } else {
                            const textToProcess = (tagStartIndex === -1) 
                                ? contentForParsing 
                                : contentForParsing.substring(0, tagStartIndex);

                            // --- 【核心恢复】使用原有的正则表达式进行句子分割 ---
                            const sentenceRegex = /(.*?)([.?!。？！…~]+|\n)/g;
                            const sentences = [...textToProcess.matchAll(sentenceRegex)];
                            let lastIndex = 0;
                            sentences.forEach(match => {
                                const sentence = (match[1] + (match[2] || '')).trim();
                                if (sentence) {
                                    messagesToSend.push({ id: Date.now() + Math.random(), sender: 'ai', type: 'text', text: sentence });
                                }
                                lastIndex = match.index + match[0].length;
                            });
                            
                            // 处理正则表达式未能匹配的剩余文本
                            if (lastIndex < textToProcess.length) {
                                const remainingText = textToProcess.substring(lastIndex).trim();
                                if (remainingText) {
                                    messagesToSend.push({ id: Date.now() + Math.random(), sender: 'ai', type: 'text', text: remainingText });
                                }
                            }
                            // --- 【恢复结束】---
    
                            contentForParsing = (tagStartIndex === -1) 
                                ? '' 
                                : contentForParsing.substring(tagStartIndex).trim();
                        }
                    }
                }
                
                if (messagesToSend.length > 0) {
                    for (const msg of messagesToSend) {
                        state.chat.history.push(msg);
                        renderChatHistory();
                        const delay = msg.type === 'text' ? (150 + (msg.text || '').length * 20) : 500;
                        await new Promise(resolve => setTimeout(resolve, Math.min(delay, 1200)));
                    }
                }
                
            } catch (error) {
                console.error("AI 回复失败:", error);
                showDialog('AI 回复失败', `错误: ${error.message}`);
            } finally {
                await saveState();
                aiReplyBtn.disabled = false;
                await triggerSuiGeneration();
            }
        }

function parseTagToMessage(tag) {
    const voiceMatch = tag.match(/^\[VOICE-?_MESSAGE\](.*)\[\/VOICE-?_MESSAGE\]$/si);
    const transferMatch = tag.match(/^\[SEND-?_TRANSFER:(.*)\]$/si);
    const stickerMatch = tag.match(/^\[USE-?_STICKER,.*?ID:(\d+).*?\]$/i);
    const actionMatch = tag.match(/^\[TRANSFER-?_ACTION:(receive|return),ID:(\d+)\]$/i);
    const htmlMatch = tag.match(/^\[HTML-?_BLOCK\](.*)\[\/HTML-?_BLOCK\]$/si);

    if (htmlMatch) {
        const htmlContent = htmlMatch[1].trim();
        if (htmlContent) return { id: Date.now(), sender: 'ai', type: 'html', htmlContent: htmlContent };
    } else if (voiceMatch) {
        const text = voiceMatch[1].trim();
        if (text) return { id: Date.now(), sender: 'ai', type: 'voice', text: text, duration: Math.max(1, Math.ceil(text.length / 3)), isExpanded: false };
    } else if (stickerMatch) {
        const stickerId = parseInt(stickerMatch[1], 10);
        const sticker = state.stickers.find(s => s.id === stickerId);
        if (sticker) return { id: Date.now(), sender: 'ai', type: 'sticker', stickerId: stickerId, meaning: sticker.meaning };
    } else if (transferMatch) {
        try {
            const payload = JSON.parse(transferMatch[1]);
            if (payload.amount > 0) return { id: Date.now(), sender: 'ai', type: 'transfer', amount: payload.amount, message: payload.message || '转账给你', status: 'pending' };
        } catch (e) { console.error('解析转账标签失败:', e); }
    } else if (actionMatch) {
        const action = actionMatch[1].toLowerCase();
        const targetId = parseInt(actionMatch[2], 10);
        const targetMsg = state.chat.history.find(m => m.id === targetId && m.sender === 'user' && m.type === 'transfer');
        if (targetMsg) {
            targetMsg.status = action === 'receive' ? 'received' : 'returned';
            showToast(action === 'receive' ? '对方已收款' : '对方已退回转账');
        }
    }
    return null;
}
        sendBtn.addEventListener('click', handleSend);
        aiReplyBtn.addEventListener('click', async () => {
            if (UILock.isLocked()) return;
            UILock.lock();
            await getAiReply();
        });

        restartChatBtn.addEventListener('click', async () => {
            const confirmed = await showDialog('新对话', '这将清除当前对话记录并重置好感度，但不会删除记忆存档。确定开始新对话吗？');
            if (confirmed) {
                state.chat.history = [];
                state.chat.affinity = 0;
                await saveState();
                renderChatHistory();
                showToast('已开始新的对话');
            }
        });

        summarizeMemoryBtn.addEventListener('click', async () => {
            // 定义固定的上下文数量
            const SUMMARY_CONTEXT_COUNT = 100;

            // 1. 前置检查
            if (state.chat.history.length === 0) {
                showDialog('无法存档', '没有聊天记录可以总结。');
                return;
            }
            if (!state.config.api.baseUrl || !state.config.api.key) {
                showDialog('API错误', '请在设置中配置API参数！').then(() => { showView('settings'); });
                return;
            }

            // 2. 用户确认 (提示信息会显示实际将总结的条数)
            const actualCount = Math.min(state.chat.history.length, SUMMARY_CONTEXT_COUNT);
            const confirmed = await showDialog('存档记忆', `确定要将最近的 ${actualCount} 条对话存档为一条新的记忆吗？`);
            if (!confirmed) return;

            // 3. 执行API调用和UI反馈
            showToast('正在总结聊天内容...');
            summarizeMemoryBtn.disabled = true;
            try {
                // 使用 slice 截取固定数量的最近消息
                const chatToSummarize = state.chat.history.slice(-SUMMARY_CONTEXT_COUNT);

                const chatContent = chatToSummarize
                    .map(msg => {
                        const sender = msg.sender === 'user' ? (state.role.playerName || '玩家') : (state.role.roleName || '角色');
                        let textContent = msg.text;
                        if (msg.type === 'voice') textContent = `(语音) ${msg.text}`;
                        if (msg.type === 'transfer') textContent = `(转账 ${msg.amount}元) ${msg.message}`;
                        if (msg.type === 'sticker') textContent = `(发送表情: ${msg.meaning})`;
                        return `${sender}：${textContent}`;
                    })
                    .join('\n');

                const systemPrompt = `你是一名记忆助手。请根据提供的对话内容，总结出关键要点、主题或重要信息，形成一个简洁、客观、第三人称的记忆存档。摘要应以“你和${state.role.roleName || '角色'}...”开头。`;
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `请总结以下对话:\n${chatContent}` }
                ];

                const response = await fetch(`${state.config.api.baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${state.config.api.key}` },
                    body: JSON.stringify({ model: state.config.api.model || 'gpt-3.5-turbo', messages: messages, temperature: 0.3 })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.error?.message || 'Unknown error'}`);
                }

                const data = await response.json();
                let summaryText = data.choices?.[0]?.message?.content;

                if (summaryText) {
                    state.memories.unshift({ id: Date.now(), content: summaryText });
                    await saveState();
                    renderMemoryList();
                    showToast('记忆已成功存档！');
                } else {
                    throw new Error("API响应为空或格式错误。");
                }
            } catch (error) {
                console.error("API请求失败:", error);
                showDialog('API请求失败', `总结记忆时发生错误: ${error.message}`);
            } finally {
                summarizeMemoryBtn.disabled = false;
            }
        });

        const renderMemoryList = () => {
            memoryListEl.innerHTML = '';
            if (state.memories.length === 0) {
                memoryListEl.innerHTML = '<p class="text-center opacity-50">还没有任何记忆存档。</p>';
                return;
            }
            // 核心修正：按ID降序排序，确保最新的在最前面
            const sortedMemories = [...state.memories].sort((a, b) => b.id - a.id);

            sortedMemories.forEach(memory => {
                const item = document.createElement('div');
                item.className = 'memory-item p-4 flex items-start justify-between space-x-4';
                
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'flex-grow';

                if (isMemoryBatchDeleteMode) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'form-checkbox h-5 w-5 mr-4 bg-white/30 rounded text-indigo-500 border-none focus:ring-0';
                    checkbox.dataset.id = memory.id;
                    contentWrapper.appendChild(checkbox);
                }

                const content = document.createElement('p');
                content.textContent = memory.content;
                contentWrapper.appendChild(content);

                const actions = document.createElement('div');
                actions.className = 'flex-shrink-0 flex space-x-2';

                if (!isMemoryBatchDeleteMode) {
                    const editBtn = document.createElement('button');
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.className = 'p-2 hover:text-blue-400';
                    editBtn.onclick = async () => {
                        const newContent = await showDialog('编辑记忆', '', { input: true, defaultValue: memory.content });
                        if (newContent) {
                            // 修正：通过ID查找并更新，而不是不稳定的索引
                            const memoryToUpdate = state.memories.find(m => m.id === memory.id);
                            if (memoryToUpdate) {
                                memoryToUpdate.content = newContent;
                            }
                            await saveState();
                            renderMemoryList();
                        }
                    };
                    actions.appendChild(editBtn);

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                    deleteBtn.className = 'p-2 hover:text-red-400';
                    deleteBtn.onclick = async () => {
                        const confirmed = await showDialog('删除记忆', '确定要删除这条记忆吗？');
                        if (confirmed) {
                            // 修正：通过ID过滤数组，而不是不稳定的索引
                            state.memories = state.memories.filter(m => m.id !== memory.id);
                            await saveState();
                            renderMemoryList();
                        }
                    };
                    actions.appendChild(deleteBtn);
                }

                item.appendChild(contentWrapper);
                item.appendChild(actions);
                memoryListEl.appendChild(item);
            });
        };

        addMemoryBtn.addEventListener('click', async () => {
            const content = await showDialog('手动添加记忆', '请输入记忆内容：', { input: true });
            if (content) {
                state.memories.push({ id: Date.now(), content: content });
                await saveState();
                renderMemoryList();
            }
        });

        batchDeleteMemoriesBtn.addEventListener('click', () => {
            isMemoryBatchDeleteMode = true;
            memoryBatchActions.classList.remove('hidden');
            addMemoryBtn.classList.add('hidden');
            batchDeleteMemoriesBtn.classList.add('hidden');
            renderMemoryList();
        });

        cancelBatchDeleteMemoriesBtn.addEventListener('click', () => {
            isMemoryBatchDeleteMode = false;
            memoryBatchActions.classList.add('hidden');
            addMemoryBtn.classList.remove('hidden');
            batchDeleteMemoriesBtn.classList.remove('hidden');
            renderMemoryList();
        });

        confirmBatchDeleteMemoriesBtn.addEventListener('click', async () => {
            const idsToDelete = Array.from(memoryListEl.querySelectorAll('input[type="checkbox"]:checked')).map(cb => parseInt(cb.dataset.id));
            if (idsToDelete.length > 0) {
                state.memories = state.memories.filter(m => !idsToDelete.includes(m.id));
                await saveState();
                isMemoryBatchDeleteMode = false;
                memoryBatchActions.classList.add('hidden');
                addMemoryBtn.classList.remove('hidden');
                batchDeleteMemoriesBtn.classList.remove('hidden');
                renderMemoryList();
                showToast(`已删除 ${idsToDelete.length} 条记忆`);
            }
        });
        
        // --- NEW: Chat Batch Delete Listeners ---
        cancelBatchDeleteChatBtn.addEventListener('click', () => {
    isChatBatchDeleteMode = false;
    stickerDrawer.classList.remove('hidden'); // <--- 核心更改：恢复面板的可渲染状态
    renderChatHistory({ autoScroll: false });
});

        confirmBatchDeleteChatBtn.addEventListener('click', async () => {
            // 1. 找到所有被选中的复选框
            const checkedBoxes = chatHistory.querySelectorAll('input[type="checkbox"]:checked');
            
            // 2. 从这些复选框旁边的消息气泡中提取出要删除的消息ID
            const idsToDelete = Array.from(checkedBoxes).map(checkbox => {
                // 复选框和消息气泡在同一个父容器内，通过父元素找到对应的消息气泡
                const bubble = checkbox.parentElement.querySelector('.message-bubble, .story-block');
                // 解析并返回消息的ID
                return bubble ? Number(bubble.dataset.id) : null;
            }).filter(id => id !== null); // 过滤掉无效的ID

            if (idsToDelete.length > 0) {
                // 3. 从聊天历史记录中过滤掉需要删除的消息
                state.chat.history = state.chat.history.filter(msg => !idsToDelete.includes(msg.id));
                
                // 4. 保存状态
                await saveState();
                
                showToast(`已删除 ${idsToDelete.length} 条消息`);
            }

            // 5. 退出批量删除模式并重新渲染界面
              isChatBatchDeleteMode = false;
    stickerDrawer.classList.remove('hidden'); // <--- 核心更改：恢复表情包面板的可渲染状态
    renderChatHistory({ autoScroll: false });
});
        // --- 新代码到此结束 ---

        const renderDiaryList = () => {
            diaryListContainer.innerHTML = '';
            if (state.diaries.length === 0) {
                diaryListContainer.innerHTML = '<p class="text-center opacity-50">TA 还没有写过日记。</p>';
                return;
            }
            const sortedDiaries = [...state.diaries].sort((a, b) => b.id - a.id);
            sortedDiaries.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'diary-entry';
                
                const header = document.createElement('div');
                header.className = 'flex justify-between items-center mb-2 border-b border-white/20 pb-2';
                const date = new Date(entry.id);
                header.innerHTML = `<span class="font-bold text-lg">${date.toLocaleDateString('zh-CN')}</span><span class="text-sm opacity-70">${date.toLocaleTimeString('zh-CN', {hour: '2-digit', minute:'2-digit'})}</span>`;

                const content = document.createElement('div');
                content.className = 'diary-content prose prose-invert max-w-none';
                let formattedContent = entry.content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/~~(.*?)~~/g, '<del>$1</del>')
                    .replace(/\n/g, '<br>');
                content.innerHTML = formattedContent;

                if (isDiaryBatchDeleteMode) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'batch-delete-checkbox form-checkbox h-5 w-5 bg-white/30 rounded text-indigo-500 border-none focus:ring-0';
                    checkbox.dataset.id = entry.id;
                    item.appendChild(checkbox);
                    item.classList.add('pl-12');
                } else {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
                    deleteBtn.className = 'diary-delete-btn';
                    deleteBtn.onclick = async () => {
                        const confirmed = await showDialog('删除日记', '确定要删除这篇日记吗？');
                        if (confirmed) {
                            state.diaries = state.diaries.filter(d => d.id !== entry.id);
                            await saveState();
                            renderDiaryList();
                        }
                    };
                    item.appendChild(deleteBtn);
                }

                item.appendChild(header);
                item.appendChild(content);
                diaryListContainer.appendChild(item);
            });
        };

        async function generateDiaryEntry() {
            try {
                // 1. 检查基本条件
                if (state.chat.history.length === 0) {
                    showDialog('无法生成', '还没有任何对话记录。');
                    return;
                }
                if (!state.config.api.baseUrl || !state.config.api.key || !state.config.api.model) {
                    showDialog('API错误', '请在设置中完整配置API参数（地址、密钥、模型名称）！').then(() => { showView('settings'); });
                    return;
                }

                showToast('正在准备日记内容...');
                generateDiaryBtn.disabled = true;

                // 2. 构建你的提示词
                const systemPrompt = `你叫 ${state.role.roleName || '角色'}, 你的设定是: ${state.role.rolePersona}. 你正在与名为 ${state.role.playerName || '玩家'} 的人互动。\n请你以第一人称视角，根据你们的共同记忆和最近的对话，写一篇充满感情、至少200字的日记。\n共同记忆: ${state.memories.map(m => `- ${m.content}`).join('\n') || '暂无'}\n最近的对话(最多20条):\n${state.chat.history.slice(-20).map(msg => `${msg.sender === 'user' ? state.role.playerName || '玩家' : '我'}: ${msg.text}`).join('\n')}\n\n写作要求:\n- 风格必须是私密的日记风格，展现你的内心世界和对玩家的真实感受。\n- 必须超过200字。\n- 使用Markdown语法来强调: **加粗表示强烈的感情**, *斜体表示悄悄的想法或疑问*, ~~删除线表示被否定或放弃的念头~~。\n- 直接开始写日记内容，不要有“亲爱的日记”或任何标题、禁止日期开头。`;

                // 3. 【回归OpenAI格式】根据服务器最新的要求，使用 'messages' 格式
                const requestBody = {
                    model: state.config.api.model,
                    messages: [{ role: 'system', content: systemPrompt }],
                    temperature: 0.8
                };

                // 4. 发送API请求
                showToast('TA正在提笔写日记...');
                const response = await fetch(`${state.config.api.baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${state.config.api.key}` },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMessage = errorData.error?.message || errorData.message || '未知';
                    throw new Error(`API响应错误: ${response.status}. 信息: ${errorMessage}`);
                }

                const data = await response.json();
                
                // 5. 【回归OpenAI格式】从 'choices' 中解析响应
                const diaryContent = data.choices?.[0]?.message?.content;

                // 6. 处理结果并更新UI
                if (diaryContent) {
                    state.diaries.unshift({ id: Date.now(), content: diaryContent });
                    await saveState();
                    renderDiaryList();
                    showToast('一篇新的日记已生成！');
                } else {
                    throw new Error("API响应为空或格式不正确，无法解析出日记内容。");
                }
            } catch (error) {
                console.error("生成日记失败:", error);
                showDialog('生成失败', `在执行过程中发生错误: ${error.message}`);
            } finally {
                generateDiaryBtn.disabled = false;
            }
        }

        generateDiaryBtn.addEventListener('click', generateDiaryEntry);

        batchDeleteDiariesBtn.addEventListener('click', () => {
            isDiaryBatchDeleteMode = true;
            diaryBatchActions.classList.remove('hidden');
            generateDiaryBtn.classList.add('hidden');
            batchDeleteDiariesBtn.classList.add('hidden');
            renderDiaryList();
        });

        cancelBatchDeleteBtn.addEventListener('click', () => {
            isDiaryBatchDeleteMode = false;
            diaryBatchActions.classList.add('hidden');
            generateDiaryBtn.classList.remove('hidden');
            batchDeleteDiariesBtn.classList.remove('hidden');
            renderDiaryList();
        });

        confirmBatchDeleteBtn.addEventListener('click', async () => {
            const idsToDelete = Array.from(diaryListContainer.querySelectorAll('input[type="checkbox"]:checked')).map(cb => parseInt(cb.dataset.id));
            if (idsToDelete.length > 0) {
                state.diaries = state.diaries.filter(d => !idsToDelete.includes(d.id));
                await saveState();
                isDiaryBatchDeleteMode = false;
                diaryBatchActions.classList.add('hidden');
                generateDiaryBtn.classList.remove('hidden');
                batchDeleteDiariesBtn.classList.remove('hidden');
                renderDiaryList();
                showToast(`已删除 ${idsToDelete.length} 篇日记`);
            }
        });
        
        // --- SUI Page Logic ---
        const renderSuiPage = () => {
            if (!state.sui) state.sui = { balance: 0, transactions: [], otherChats: [], browsingHistory: [] };
            suiBalanceEl.textContent = state.sui.balance.toFixed(2);
            renderSuiTransactions();
            renderSuiOtherChats();
            renderSuiBrowsingHistory();
        };

        const renderSuiTransactions = () => {
            suiTransactionsListEl.innerHTML = '';
            if (!state.sui.transactions || state.sui.transactions.length === 0) {
                suiTransactionsListEl.innerHTML = '<p class="opacity-70 text-center">暂无记录</p>'; return;
            }
            state.sui.transactions.forEach(t => {
                const item = document.createElement('div');
                item.className = 'sui-list-item transaction-item';
                const amountClass = t.amount > 0 ? 'amount-positive' : 'amount-negative';
                item.innerHTML = `
                    <div class="sui-item-actions">
                        <button class="sui-action-btn" data-action="add-to-memory" data-type="transactions" data-id="${t.id}" title="存为记忆"><i class="fas fa-bookmark"></i></button>
                        <button class="sui-action-btn" data-action="delete" data-type="transactions" data-id="${t.id}" title="删除"><i class="fas fa-trash-alt"></i></button>
                    </div>
                    <span class="timestamp">${t.timestamp}</span>
                    <p>${t.description}</p>
                    <div class="amount-display">
                        <span class="${amountClass} font-mono">${t.amount.toFixed(2)}</span>
                    </div>
                `;
                suiTransactionsListEl.appendChild(item);
            });
        };

        const renderSuiOtherChats = () => {
            suiOtherChatsListEl.innerHTML = '';
            if (!state.sui.otherChats || state.sui.otherChats.length === 0) {
                suiOtherChatsListEl.innerHTML = '<p class="opacity-70 text-center">暂无记录</p>'; return;
            }
            state.sui.otherChats.forEach(c => {
                const item = document.createElement('div');
                item.className = 'sui-list-item';

                // 检查 c.log 是否为有效数组，如果不是，则提供一个提示，防止程序崩溃
                const logHtml = Array.isArray(c.log)
                    ? c.log.map(l => `<p><strong>${l.sender || '未知'}:</strong> ${l.text || ''}</p>`).join('')
                    : '<p class="opacity-50">[数据不完整，无法显示对话]</p>';
                
                item.innerHTML = `
                    <div class="sui-item-actions">
                        <button class="sui-action-btn" data-action="add-to-memory" data-type="otherChats" data-id="${c.id}" title="存为记忆"><i class="fas fa-bookmark"></i></button>
                        <button class="sui-action-btn" data-action="delete" data-type="otherChats" data-id="${c.id}" title="删除"><i class="fas fa-trash-alt"></i></button>
                    </div>
                    <span class="timestamp">${c.timestamp}</span>
                    <p>与 <span class="chat-with">${c.with}</span> 的对话</p>
                    <div class="sui-chat-log">${logHtml}</div>
                `;
                suiOtherChatsListEl.appendChild(item);
            });
        };

        const renderSuiBrowsingHistory = () => {
            suiBrowsingHistoryListEl.innerHTML = '';
            if (!state.sui.browsingHistory || state.sui.browsingHistory.length === 0) {
                suiBrowsingHistoryListEl.innerHTML = '<p class="opacity-70 text-center">暂无记录</p>'; return;
            }
            state.sui.browsingHistory.forEach(h => {
                const item = document.createElement('div');
                item.className = 'sui-list-item';
                const sessionHtml = h.session.map(p => `<p>${p.title}<br><span class="url">${p.url}</span></p>`).join('');
                item.innerHTML = `
                    <div class="sui-item-actions">
                        <button class="sui-action-btn" data-action="add-to-memory" data-type="browsingHistory" data-id="${h.id}" title="存为记忆"><i class="fas fa-bookmark"></i></button>
                        <button class="sui-action-btn" data-action="delete" data-type="browsingHistory" data-id="${h.id}" title="删除"><i class="fas fa-trash-alt"></i></button>
                    </div>
                    <span class="timestamp">${h.timestamp}</span>
                    <p>浏览会话</p>
                    <div class="sui-browsing-session">${sessionHtml}</div>
                `;
                suiBrowsingHistoryListEl.appendChild(item);
            });
        };

        suiNav.addEventListener('click', (e) => {
            const targetBtn = e.target.closest('.sui-nav-btn');
            if (!targetBtn) return;
            
            suiNavBtns.forEach(btn => btn.classList.remove('active'));
            targetBtn.classList.add('active');
            
            const targetSectionId = targetBtn.dataset.target;
            suiContentSections.forEach(section => {
                section.classList.toggle('hidden', section.id !== targetSectionId);
            });
        });

        const clearSuiSection = async (sectionKey, sectionName, renderFunc) => {
            const confirmed = await showDialog('确认清空', `确定要清空所有“${sectionName}”记录吗？此操作不可撤销。`);
            if (confirmed) {
                if (sectionKey === 'transactions') {
                    state.sui.transactions = [];
                } else if (sectionKey === 'otherChats') {
                    state.sui.otherChats = [];
                } else if (sectionKey === 'browsingHistory') {
                    state.sui.browsingHistory = [];
                }
                await saveState();
                renderFunc();
                showToast(`已清空${sectionName}记录`);
            }
        };

        suiClearAccountBtn.addEventListener('click', () => clearSuiSection('transactions', '交易', renderSuiTransactions));
        suiClearCommsBtn.addEventListener('click', () => clearSuiSection('otherChats', '外部通讯', renderSuiOtherChats));
        suiClearBrowsingBtn.addEventListener('click', () => clearSuiSection('browsingHistory', '浏览', renderSuiBrowsingHistory));
        
         // --- NEW: SUI Item Interaction Handler (ULTRA-SAFE FIX) ---
        suiContentContainer.addEventListener('click', async (e) => {
            const btn = e.target.closest('.sui-action-btn');
            if (!btn || btn.disabled) return;

            const action = btn.dataset.action;
            const type = btn.dataset.type;
            const idFromButton = btn.dataset.id; // 从按钮获取ID，保持为字符串

            if (!action || !type || !idFromButton) return;

            // 【核心修正】: 将数据中的ID和按钮的ID都强制转换为字符串再进行严格比较 (===)
            // 这是最安全、最明确的比较方式，可以彻底避免类型问题。
            const itemData = state.sui[type].find(item => String(item.id) === idFromButton);

            if (!itemData) {
                showDialog('内部错误', `无法在数据中找到ID为 ${idFromButton} 的项目。`);
                return;
            }

            if (action === 'delete') {
                const confirmed = await showDialog('确认删除', '确定要删除这条记录吗？');
                if (confirmed) {
                    // 同样使用安全的字符串比较来进行过滤
                    state.sui[type] = state.sui[type].filter(item => String(item.id) !== idFromButton);
                    await saveState();
                    if (type === 'transactions') renderSuiTransactions();
                    else if (type === 'otherChats') renderSuiOtherChats();
                    else if (type === 'browsingHistory') renderSuiBrowsingHistory();
                    showToast('记录已删除');
                }
            } else if (action === 'add-to-memory') {
                btn.disabled = true;

                try {
                    let memoryContent = '';
                    const roleName = state.role.roleName || 'TA';

                    switch (type) {
                        case 'transactions':
                            memoryContent = `在SUI监控中发现一条交易记录：\n时间: ${itemData.timestamp}\n描述: ${itemData.description}\n金额: ${itemData.amount.toFixed(2)}`;
                            break;
                        case 'otherChats':
                            const chatLog = Array.isArray(itemData.log) ? itemData.log.map(l => `${l.sender}: ${l.text}`).join('\n') : '[数据不完整]';
                            memoryContent = `在SUI监控中发现一段通讯记录 (与 ${itemData.with}, 时间: ${itemData.timestamp})：\n${chatLog}`;
                            break;
                        case 'browsingHistory':
                            const pageTitles = Array.isArray(itemData.session) ? itemData.session.map((p, index) => `${index + 1}. ${p.title}`).join('\n') : '[数据不完整]';
                            memoryContent = `在SUI监控中发现一段浏览记录 (时间: ${itemData.timestamp})，${roleName} 浏览了以下页面：\n${pageTitles}`;
                            break;
                    }

                    if (!memoryContent) {
                        throw new Error('生成的记忆内容为空，无法添加。');
                    }

                    const isDuplicate = state.memories.some(mem => mem.content === memoryContent);
                    if (isDuplicate) {
                        showToast('该记忆已存在');
                        btn.innerHTML = '<i class="fas fa-check-double"></i>';
                        btn.title = '已存在';
                        return;
                    }

                    state.memories.unshift({ id: Date.now(), content: memoryContent });
                    await saveState();
                    renderMemoryList();

                    btn.innerHTML = '<i class="fas fa-check"></i>';
                    btn.title = '已添加';
                    showToast('已成功存为记忆！');

                } catch (error) {
                    console.error('在 "存为记忆" 过程中发生错误:', error);
                    showDialog('操作失败', `在添加记忆时发生错误：<br><br><strong>${error.message}</strong><br><br>请检查控制台获取详细信息。`);
                    btn.disabled = false;
                }
            }
        });


        // --- Multifunction Menu & Chat Features ---
        multifunctionToggleBtn.addEventListener('click', () => {
            multifunctionMenu.classList.toggle('hidden');
            if (!multifunctionMenu.classList.contains('hidden')) {
                stickerDrawer.classList.remove('open');
            }
        });

        transferBtn.addEventListener('click', async () => {
            const result = await showDialog('转账', '', {
                complexInput: `
                    <div class="space-y-2">
                        <input type="number" id="transfer-amount" class="w-full p-2 border-none rounded-md bg-white/20" placeholder="金额">
                        <input type="text" id="transfer-message" class="w-full p-2 border-none rounded-md bg-white/20" placeholder="留言 (可选)">
                    </div>
                `,
                getValues: () => ({
                    amount: parseFloat(get('transfer-amount').value) || 0,
                    message: get('transfer-message').value
                })
            });

            if (result && result.amount > 0) {
                await sendMessage({
                    id: Date.now(), sender: 'user', type: 'transfer',
                    amount: result.amount, message: result.message || '转账给你', status: 'pending'
                });
            }
        });
        
        voiceModeBtn.addEventListener('click', () => {
            state.chat.sendMode = state.chat.sendMode === 'voice' ? 'text' : 'voice';
            const isVoiceMode = state.chat.sendMode === 'voice';
            voiceModeBtn.classList.toggle('text-blue-400', isVoiceMode);
            userInput.placeholder = isVoiceMode ? '输入语音文字...' : '请输入消息...';
            showToast(isVoiceMode ? '已切换到语音模式' : '已切换到文本模式');
        });

         storyModeBtn.addEventListener('click', async () => {
            const isCurrentlyStoryMode = state.chat.mode === 'story';

            if (isCurrentlyStoryMode) {
                // --- 新逻辑：退出剧情模式，并将当前剧情打包为占位符 ---
                state.chat.mode = 'phone';
                
                // 在历史记录的末尾添加一个“剧情结束”的标记
                state.chat.history.push({
                    id: Date.now(),
                    sender: 'system',
                    type: 'story_end', // 新的结束标记类型
                    text: '--- 剧情结束 ---'
                });

                // 找到最后一个“剧情开始”和对应的“剧情结束”标记的索引
                const storyStartIndex = state.chat.history.findLastIndex(msg => msg.type === 'story_start');
                const storyEndIndex = state.chat.history.findLastIndex(msg => msg.type === 'story_end');

                if (storyStartIndex !== -1 && storyEndIndex > storyStartIndex) {
                    // 1. 从 history 中“剪切”出这段剧情的所有消息（包括开始和结束标记）
                    const messagesToArchive = state.chat.history.splice(storyStartIndex, storyEndIndex - storyStartIndex + 1);

                    // 2. 创建一个“占位符”对象，并将剪切出来的内容存入其中
                    const placeholder = {
                        id: Date.now() + 1, // 确保ID唯一
                        type: 'story_review_placeholder', // 新的占位符类型
                        sender: 'system',
                        archivedContent: messagesToArchive // 核心：保存被收纳的内容
                    };

                    // 3. 将这个占位符插入到被剪切内容的原位置
                    state.chat.history.splice(storyStartIndex, 0, placeholder);
                }

                showToast('已返回手机模式');

            } else {
                // --- 进入剧情模式 (逻辑不变) ---
                state.chat.mode = 'story';
                // 插入一个“剧情开始”的标记，用于后续的收纳操作
                state.chat.history.push({ 
                    id: Date.now(), 
                    sender: 'system', 
                    type: 'story_start', // 特殊类型
                    text: '--- 切换到剧情模式 ---' 
                });
                showToast('已进入剧情模式');
            }

            await saveState();
            renderChatHistory({ autoScroll: true });
        });

        stickerPanelBtn.addEventListener('click', () => {
            stickerDrawer.classList.toggle('open');
            if (stickerDrawer.classList.contains('open')) {
                multifunctionMenu.classList.add('hidden');
            }
        });
        const imageBtn = get('image-btn');
const imageUploadInput = get('image-upload-input');

imageBtn.addEventListener('click', () => {
    imageUploadInput.click();
});

imageUploadInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (event) => {
        const imageUrl = event.target.result;
        const imageMessage = {
            id: Date.now(),
            sender: 'user',
            type: 'image',
            imageUrl: imageUrl,
            text: `[用户发送了一张图片]`
        };
        await sendMessage(imageMessage);
    };
    reader.readAsDataURL(file);
    e.target.value = '';
});
        closeStickerDrawerBtn.addEventListener('click', () => stickerDrawer.classList.remove('open'));

        const renderStickerDrawer = () => {
            stickerGrid.innerHTML = '';
            if (state.stickers.length === 0) {
                stickerGrid.innerHTML = '<p class="opacity-50 text-center col-span-full">还没有表情包，快去添加吧！</p>';
            }
            state.stickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `
                    <img src="${sticker.imageDataUrl}" alt="${sticker.meaning}">
                    <button class="sticker-item-delete" data-id="${sticker.id}"><i class="fas fa-times"></i></button>
                `;
                item.querySelector('img').addEventListener('click', async () => {
                    await sendMessage({ id: Date.now(), sender: 'user', type: 'sticker', stickerId: sticker.id, meaning: sticker.meaning });
                    stickerDrawer.classList.remove('open');
                });
                item.querySelector('.sticker-item-delete').addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const confirmed = await showDialog('删除表情', `确定要删除这个含义为“${sticker.meaning}”的表情吗？`);
                    if (confirmed) {
                        state.stickers = state.stickers.filter(s => s.id !== sticker.id);
                        await db.delete('stickers', sticker.id);
                        await saveState();
                        renderStickerDrawer();
                    }
                });
                stickerGrid.appendChild(item);
            });
        };

        addStickerBtn.addEventListener('click', () => stickerUploadInput.click());

        stickerUploadInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const meaning = await showDialog('添加表情', '这个表情代表什么意思？', { input: true, placeholder: '例如：开心、疑惑、抱抱' });
            if (!meaning) return;

            const reader = new FileReader();
            reader.onload = async (event) => {
                const newSticker = {
                    id: Date.now(),
                    meaning: meaning,
                    imageDataUrl: event.target.result
                };
                state.stickers.push(newSticker);
                await db.set('stickers', newSticker.id, newSticker);
                await saveState();
                renderStickerDrawer();
                showToast('表情已添加');
            };
            reader.readAsDataURL(file);
        });

        // --- Data Management ---
        exportDataBtn.addEventListener('click', async () => {
            try {
                const stateToExport = JSON.parse(localStorage.getItem('game_state_v5') || '{}');
                stateToExport.version = APP_VERSION;
                const dataStr = JSON.stringify(stateToExport);
                const dataBlob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.download = `攻略计划_存档_${new Date().toISOString().slice(0,10)}.json`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                showToast('数据已导出');
            } catch (e) {
                showDialog('导出失败', '无法导出数据，详情请查看控制台。');
                console.error('Export failed:', e);
            }
        });

        importDataBtn.addEventListener('click', () => importFileInput.click());

        importFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const importedState = JSON.parse(event.target.result);
                    const confirmed = await showDialog('导入数据', '这将覆盖你当前的所有进度和设置，确定要导入吗？导入后页面将自动刷新。');
                    if (confirmed) {
                        localStorage.setItem('game_state_v5', JSON.stringify(importedState));
                        showToast('导入成功，正在刷新...');
                        setTimeout(() => window.location.reload(), 1500);
                    }
                } catch (error) {
                    showDialog('导入失败', '文件格式错误或已损坏。');
                }
            };
            reader.readAsText(file);
        });

        // Initial Load
        await loadState();
        initTouchEffects();

    })();
</script>
</body>
</html>